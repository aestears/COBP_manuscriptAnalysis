---
title: "Integral Projection Models for *Oenothera coloradensis*: Analysis of Vital Rate Buffering"
author: "Alice Stears"
date: "2023-05-16"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(popbio)
```

## IPM Equations

#### continuous, above-ground state:
$$ n(z',t_1) = \int^U_L [1-P_b(z)]s(z)G(z',z)n(z,t)dz + goCont \int^U_LP_b(z)b(z)c_o(z')n(z,t)dz + outSB[B(t)c_o(z')]$$     

#### discrete, seedbank state:
$$ B(t+1) = goSB \int^U_LP_b(z)b(z)n(z,t)dz + B(t)staySB$$    

where:

-   $G(z',z)$ is the distribution of plant size in year *t+1* as a
    function of size in year *t*\
-   $s(z)$ is the probability of survival based on size in year *t*\
-   $P_b(z)$ is the probability of flowering based on size in year
    *t*\
-   $b(z)$ is the number of seeds produced by a flowering plant based
    on size in year *t*\
-   $c_o(z')$ is the distribution of above-ground recruit size in
    year *t+1*        
-   $goCont$ is the discrete probability of a seed produced in year *t* germinating as a seedling in year *t+1*       
-   $outSB$ is the discrete probability of a seed from the seedbank in year *t* germinating as a seedling in year *t+1*       
-   $goSB$ is the discrete probability of a seed produced in year *t* going to the seedbank in year *t+1*       
-   $staySB$ is the discrete probability of a seedbank seed in year *t* persisting in the seedbank in year *t+1*        

## Prepare to make IPMs

#### load data

```{r}
# location of files
datFolder <- "~/Dropbox/Work/Grad School/Research/Oenothera coloradensis project"
# load data file
dat_all <- read.csv(file = paste0(datFolder, "/Processed_Data/allDat_plus_contSeedlings.csv"))
```

## Make IPMs 
Below is example code showing how I created an IPM for one of the six sub-populations. In this analysis, I calculated an IPM for each sub-population in each transition (a total of 12 IPMs, called IPMs CC through NN), which were used to calculate the mean and standard deviations of each vital rate. I also calculated an IPM using data from all subpopulations in both transitions, which I used to calculate sensitivity and elasticity for each vital rate. All of these IPMs used the same structure, but had different vital rate function parameters. 
```{r, eval = FALSE}
# establish upper and lower bounds of the continous state
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum ln(size), -2.8
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum ln(size), 4.4

n <-500 # bins

# These are the parameters for the discrete stages
outSB <- outSB_all #SB to continuous stage, 0.14
staySB <- staySB_all # staying in SB, 0.75
goCont <- goCont_all # seeds become continuous right away (without going to the seed bank), 0.09
goSB <- goSB_all # seeds go to the seedbank, 0.49
surv.seeds <-  0.9 # survival of seeds

## make an IPM for the "Crow Creek" site in the 2019-2020 transition
i <- 1
  ## get data for this 'current' site
  dat_now <- dat_all[dat_all$Site == unique(dat_all$Site)[i] # data for this site
                     & dat_all$Year == 2019# data for this year
                     ,]
  
  ## fit vital rate models
  ## Survival ($s(z)$)
  survDat_now <- dat_now[dat_now$flowering==0 | is.na(dat_now$flowering),]
  survMod_now <- glm(survives_tplus1 ~ log_LL_t , data = survDat_now, family = binomial)
  ## Growth ($G(z',z)$)
  sizeMod_now <- lm(log_LL_tplus1 ~ log_LL_t , data = dat_now)
  ## Number of seeds produced, according to plant size ($b(z)$)
  seedDat_now <- dat_now[dat_now$flowering==1,]
  # fit poisson glm (for count data)
  seedMod_now <- MASS::glm.nb(Num_seeds ~ log_LL_t , data = seedDat_now)
  ## Flowering probability ($p_b(z)$)
  flwrMod_now <- suppressWarnings((glm(flowering ~ log_LL_t + I(log_LL_t^2) , data = dat_now, family = binomial)))
  ## Distribution of recruit size ($c_o(z')$)
  # subset the data
  recD_now <- dat_all[dat_all$seedling == 1 & dat_all$Year == 2020,]
  # fit the model
  recMod_now <- lm(log_LL_t ~ 1, data = recD_now)
  
  ## put in the parameter list (paramCont)
  paramCont <- list(
    g_int     = coef(sizeMod_now)[1], # growth 
    g_slope   = coef(sizeMod_now)[2],
    g_sd      = summary(sizeMod_now)$sigma,
    s_int     = coef(survMod_now)[1], # survival
    s_slope   = coef(survMod_now)[2],
    p_b_int   = coef(flwrMod_now)[1], #probability of flowering
    p_b_slope = coef(flwrMod_now)[2],
    p_b_slope_2 = coef(flwrMod_now)[3],
    b_int   = coef(seedMod_now)[1], #seed production
    b_slope = coef(seedMod_now)[2],
    c_o_mu    = coef(recMod_now), #recruit size distribution
    c_o_sd    = summary(recMod_now)$sigma,
    outSB  = outSB_all,
    staySB = staySB_all,
    goSB   = goSB_all, 
    goCont = goCont_all                  
  )
  ## make vital rate functions for the IPM
  # SURVIVAL:
  S.fun <- function(z, paramCont) {
    mu.surv=paramCont$s_int + paramCont$s_slope *z
    return(1/(1 + exp(-(mu.surv))))
  }
  # GROWTH (we assume a constant variance)
  GR.fun <- function(z,zz, paramCont){
    growth.mu = paramCont$g_int + paramCont$g_slope*z
    return(dnorm(zz, mean = growth.mu, sd = paramCont$g_sd))
  }
  ## SEEDLING SIZES (same approach as in growth function)
  SDS.fun <- function(zz, paramCont){
    rec_mu <- paramCont$c_o_mu
    rec_sd <- paramCont$c_o_sd
    return(dnorm(zz, mean = rec_mu, sd = rec_sd))
  }
  # PROBABILITY OF FLOWERING 
  FL.fun <- function(z, paramCont) {
    mu.fl = paramCont$p_b_int + paramCont$p_b_slope*z +  paramCont$p_b_slope_2 * (z^2)
    return(1/(1+ exp(-(mu.fl))))
  }
  # SEED PRODUCTION
  SDP.fun <- function(z, paramCont) {
    mu.fps=exp(paramCont$b_int + paramCont$b_slope *z)
    return(mu.fps)
  }
  
  ## fit the IPM
  K <- array(0,c(n+1,n+1))
  # Setting up the kernels
  b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
  meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
  h=(U-L)/n # bin width 
  # Survival and growth 
  S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
  G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth
  # G <- t(outer(meshp,meshp,GR.fun)) # Growth
  #Recruits distribution (seeds recruited from the seedbank into the continuous stage)
  c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)
  # c_o <- matrix(rep(SDS.fun(meshp),n),n,n,byrow=F)
  #Probability of flowering
  Pb = (FL.fun(meshp, paramCont))
  #Number of seeds produced according to adult size
  b_seed = (SDP.fun(meshp, paramCont))
  FecALL= Pb * b_seed
  # update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
  S_new <- S * (1-Pb)
  # Control for eviction:
  # this is equivalent to redistributing evicted sizes evenly among existing size classes 
  G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
  c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)
  # make the continuous part of the P matrix
  Pkernel.cont <- as.matrix(G %*% S_new)
  # seedbank (first column of your K)
  Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous
  # Make the full P kernel
  Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component
  ## make the F kernel
  Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class
  Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)
  Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))
  
  mat <-Pkernel+Fkernel
  
  eigenMat <- eigen(mat)
  
  IPMs_II_NN[[i]] <- list(KMatrix = mat,
                          GMatrix = G, 
                          SMatrix = S_new,
                          FMatrix = Fkernel.cont,
                          staySB_vec = staySB, 
                          leaveSB_vec = as.matrix((outSB*c_o[,1]), nrow = 500, ncol = 1), 
                          goSB_vec = matrix(c( goSB * (FecALL)), nrow = 1),
                          params = paramCont)

```
#### To save time, we can load the saved IPMs that were calculated previously
```{r, message=FALSE}
# subpopulation-level, each transition IPMs
IPMs_CC_HH <- readRDS(paste0(datFolder,"/COBP_analysis/intermediate_analysis_Data/site_level_IPMs_eachYear/IPMs_CC_HH.RDS"))
IPMs_II_NN <- readRDS(paste0(datFolder,"/COBP_analysis/intermediate_analysis_Data/site_level_IPMs_eachYear/IPMs_II_NN.RDS"))
# all populations, all transitions IPM
load(paste0(datFolder,"/COBP_analysis/intermediate_analysis_Data/allSiteAllYears_noDDnoEnv/ipmA_B_results.RData"))
```

## Calculate mean and corrected standard deviation of Vital Rates
#### * Based on the VSS code for matrix models that Maria Paniw shared

Put all of the IPMs for each subpopulation/transition into one big list
```{r}
allIPMs <- c(IPMs_II_NN, IPMs_CC_HH)

# also define the vector of meshpoints that is used to make each IPM (which we'll need to calculate vital rate functions in the IPM)
n <- 500
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum ln(size), -2.8
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum ln(size), 4.4
# calculate the meshpoints
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)])
# calculate the binwidth
h <- diff(meshp)[1]
```

In this section we first extract the underlying vital rates, to then calculate their corrected standard deviation (according to McDonald et al. 2017). The corrections are required because we want to be able to include in the same analysis vital rates such as survival and growth (bounded between 0 and 1) and fecundity (bounded only by 0). The variance of 0-1 vital rates is constrained by a lower and upper limit, therefore these vital rates have to be transformed to free variance from this constraint.

#### Survival ($s(z)$) 
Use the survival function w/ parameters for each IPM to calculate the survival vector for each IPM (want just survival, not survival - probability of flowering)
```{r}
# survival function from the IPM
S.fun <- function(z, paramCont) {
  mu.surv=paramCont$s_int + paramCont$s_slope *z 
  return(1/(1 +exp(-(mu.surv)))) }
# calculate the survival probability based on model parameters for each IPM
# surv is a matrix with 500 rows (one for each meshpoint) and 12 columns (one for each subpop/year)
surv <- sapply(allIPMs, FUN = function(x) 
  S.fun(z =
meshp, paramCont = x$params) )

#Get the mean survival vector over all 12 IPMs (surv.mu is a vector with the mean survival rate for each cell of the IPM)
surv.mu <- apply(surv, 1, mean)

#Get the standard deviation of survival over all of the IPMs
surv.sd <- apply(surv, 1, sd)

# get the corrected sd (use a logit transformation, since it is a probability)
# (McDonald et al. (2017) used logit transformation on 0-1 vital rates)
corr.surv.sd <- apply(car::logit(surv,adjust = 0.001), 1 ,sd)
```

#### Probability of Flowering $(P_b(z))$

Use the flowering function w/ parameters for each IPM to calculate the P(flowering) vector for each IPM
```{r}
# PROBABILITY OF FLOWERING
FL.fun <- function(z, paramCont) { 
  mu.fl = paramCont$p_b_int + paramCont$p_b_slope*z + paramCont$p_b_slope_2* (z^2) 
  return(1/(1+ exp(-(mu.fl)))) }

# calculate the flowering probability based on model parameters for each IPM
flowering <- lapply(allIPMs, 
                    FUN = function(x) 
  FL.fun(z = meshp, paramCont = x$params) 
  ) 
# at this point, 'flowering' is a list where each list element is for a subpop/year, and contains a vector of flowering probabilities
# we need to make this into a full matrix
# first, make the continuous part (put the flowering probability vector on the diagonal)
flowering.cont <- lapply(flowering, 
                         FUN = function(x)
                           as.matrix(diag(x))
                         ) 

# add discrete part (contribution of flowering probability to the seedbank) 
flowering.disc <- lapply(flowering, 
                         FUN = function(x) 
                           matrix(c(0, x), nrow = 1)
                         )

# combine into one matrix
for (i in 1:length(flowering.cont)) { 
  flowering[[i]] <-
    rbind(flowering.disc[[i]], cbind(rep(0, length.out = 500),
                                     flowering.cont[[i]])) 
  }

# Now, calculate the mean flowering probability
# get a matrix that is an average of all of the different Fmats from each IPM 
flowering.mu <- apply(simplify2array(flowering), 1:2, mean) 

# sd of fecundity 
flowering.sd <- apply(simplify2array(flowering), 1:2, sd) 

# get the corrected sd (use a logit transformation, since it is a probability) McDonald et al. (2017) used logit transformation on 0-1 vital rates
corr.flowering.sd <- apply(car::logit(simplify2array(flowering),adjust = 0.001), 1:2 ,sd) 
```


#### Seed production ($b(z)$)

Use the seed production function w/ parameters for each IPM to calculate the seed production vector for each IPM
```{r}
# SEED PRODUCTION
SDP.fun <- function(z, paramCont) {
  mu.fps = exp(paramCont$b_int + paramCont$b_slope * z)
  return(mu.fps)
}

# calculate seed production based on model parameters for each IPM
seedProd <- lapply(
  allIPMs,
  FUN = function(x)
    SDP.fun(z = meshp, paramCont = x$params)
)


# at this point, 'seedProd' is a list where each list element is for a subpop/year, and contains a vector of seed production
# we need to make this into a full matrix
# first, make the continuous part (put the seed production vector on the diagonal)
seedProd.cont <- lapply(
  seedProd,
  FUN = function(x)
    as.matrix(diag(x))
)

# add discrete part (contribution of flowering probability to the seedbank)
seedProd.disc <- lapply(
  seedProd,
  FUN = function(x)
    matrix(c(0, x), nrow = 1)
)

# combine into one matrix
for (i in 1:length(seedProd.cont)) {
  seedProd[[i]] <-
    rbind(seedProd.disc[[i]], cbind(rep(0, length.out = 500),
                                    seedProd.cont[[i]]))
}

# are there any values of 0 in the seed production matrices?
unlist(lapply(seedProd, FUN = function(x) sum(x==0))) >0

# Since the correction that we must apply to fecundities is the
# log-transformation, we encounter problems when the the vital rate has a value
# of 0. The following if-else loops are needed to deal with fecundity matrices
# with "0" entries where they should have a positive value (0s are a problem
# because log transformation can't be done on the value "0"). Therefore, we add
# a small value (0.01) to the fecundity value which is 0, over all the years of
# the study. This way, we keep a biological meaning, and we stay consistent.

seedProd <- lapply(
  seedProd,
  FUN =
    function(x)
      replace(x, list = which(x == 0, arr.ind = TRUE), values =
                .0001)
) 

#Now, calculate mean seedProd probability
seedProd.mu <- apply(simplify2array(seedProd), 1:2, mean) 
# this is a matrix that is an average of all of the different seed production matrices from each IPM 

# sd of seed production 
seedProd.sd <- apply(simplify2array(seedProd), 1:2, sd)

# get the corrected sd (use a log transformation, since it is NOT a probability) 
corr.seedProd.sd <- apply(log(simplify2array(seedProd)), 1:2 ,sd) 
```

#### Growth $G(z',z)$
Use the growth function w/ parameters for each IPM to calculate the growth for each IPM
```{r}
# GROWTH (we assume a constant variance)
GR.fun <- function(z, zz, paramCont) {
  growth.mu =
    paramCont$g_int + paramCont$g_slope * z 
  return(dnorm(zz, mean = growth.mu, 
               sd =  paramCont$g_sd))
} 
# calculate the growth matrix based on model parameters for each IPM
growth <-
  lapply(allIPMs,
    FUN = function(x)
      h * t(outer(meshp, meshp, GR.fun, paramCont = x$params)
            )
    ) 
# 'growth' is a list in which each element contains the growth matrix for one subpop/year
    
#Calculate the mean of growth 
growth.mean <-
    apply(simplify2array(growth), 1:2, mean) 

# sd of growth 
growth.sd <-
    apply(simplify2array(growth), 1:2, sd) 

# corrected sd of growth (use a logit transformation, since it is a probability)
corr.growth.sd <-
  apply(car::logit(simplify2array(growth), adjust = 0.001), 1:2, sd)
```

#### We don't calculate mean and sd values for seedbank parameters and seedling size distribution, because those values were calculated at the population level (so there is no variation accross subpopulations)

## Calculate Sensitivity 

The first step in calculation of the corrected sensitivity is the calculation of matrix-level sensitivity according to Silvertown and Franco (2004), and then we apply a correction according to McDonald et al. (2017)

We calculate the overall sensitivity based on the matrix from IPM B (called "mat_all_DI") (IPM for all sites and both transitions) (I think this is correct? not too sure? Should I calculate it from the mean matrix from all 12 subpop/year IPMs instead?)

### Calculate sensitivity for the entire matrix

Calculate the eigen vectors for the mean matrix (according to Ellner, Childs & Rees 2016--code in their book, pg. 96)
```{r}
# stable stage distribution
w.z <- Re(eigen(mat_all_DI)$vectors[,1])

# reproductive value
v.z1 <- Re(eigen(t(mat_all_DI))$vectors[,1])

# lambda
lambda <- Re(eigen(mat_all_DI)$values[1]) 
# calculate meshpoint size "h" 
h <- diff(meshp)[1] 
# hand-calculate kernel sensitivity 
S <- outer(v.z1, w.z, "*")/sum(v.z1* w.z * h)

# calculate elasticity as a gut check (should sum to one)

E <- S * (mat_all_DI/h) / lambda 

sum(E) * h^2 # (sums to 1!)

```

### Now, calculate vital rate sensitivity
Following code from Ellner, Childs and Rees 2016 book (pg. 98-100)
#### Preparation

First, get parameter values used to make the all pops, all transitions IPM, and save in a list
```{r}
paramCont=list(NULL) 
# survival model is called 'survMod_all'
paramCont[[1]]=as.matrix(coef(survMod_all)) 
# growth model is called 'sizeMod_all'
paramCont[[2]]=cbind(as.matrix(coef(sizeMod_all)),sd(residuals(sizeMod_all))) # the second column is for the standard deviation of growth 
# seedling size distribution is a uniform distribution (of exp(size_2)) with a min of 0.1 and a max 0f 3
paramCont[[3]]= cbind(as.matrix(coef(recMod_all)), sd(residuals(recMod_all)))
# model for probability of flowering is flwrMod_all 
paramCont[[4]]=as.matrix(coef(flwrMod_all)) 
# model for seed production per plant (if reproductive) is seedMod_all
paramCont[[5]]=as.matrix(coef(seedMod_all)) 
# name the paramCont list to keep track of coefficients 
names(paramCont) <- c("survival", "growth", "recruitDist", "flowering", "seedProduction")
```

Then, define the vital rate models that were used to make the IPM (Same as the functions used to calculate mean and sd vital rate parameter values above)
```{r}

# SURVIVAL:
S.fun <- function(z, paramCont) {
  mu.surv=paramCont[["survival"]]["(Intercept)",] + paramCont[["survival"]]["log_LL_t",]*z 
  return(1/(1 + exp(-(mu.surv)))) 
  }

# GROWTH (we assume a constant variance) 
GR.fun <- function(z,z1,paramCont){ 
  growth.mu = paramCont[["growth"]]["(Intercept)",1] +paramCont[["growth"]]["log_LL_t",1]*z 
  return(dnorm(z1, mean = growth.mu, sd = paramCont[["growth"]][1,2])) 
}

## SEEDLING SIZES (same approach as in growth function)
SDS.fun <- function(z1, paramCont){
  rec_mu <- paramCont[["recruitDist"]][1]
  rec_sd <- paramCont[["recruitDist"]][2]
  return(dnorm(z1, mean = rec_mu, sd = rec_sd))
}

# PROBABILITY OF FLOWERING 
FL.fun <- function(z, paramCont) { 
  mu.fl = paramCont[["flowering"]][1,] + paramCont[["flowering"]][2,]*z + paramCont[["flowering"]][3,]* (z^2) 
  return(1/(1+ exp(-(mu.fl)))) 
  } 

# SEED PRODUCTION 
SDP.fun <- function(z, paramCont) {
  mu.fps=exp(paramCont[["seedProduction"]][1,1] + paramCont[["seedProduction"]][2,1]*z) 
  return(mu.fps) 
  }

# meshpoints, n, and h are defined above
```

These are the parameters for the discrete stages
```{r}
outSB <- outSB_all #SB to continuous stage, 0.14
staySB <- staySB_all # staying in SB, 0.75
goCont <- goCont_all # seeds become continuous right away (without going to the seed bank), 0.09
goSB <- goSB_all # seeds go to the seedbank, 0.49
surv.seeds <-  0.9 # survival of seeds
```

#### Sensitivity to Survival $s(z)$    
Based on code and details from the Ellner, Childs and Rees book
Function: $$\frac{\delta\lambda}{\delta s(z_0)} = \frac{\int v(z')(1-P_b(z_o))G(z',z_0)w(z)dz'}{\int v(z)w(z)dz}$$
, where $v(z)$ is the reproductive value distribution and $w(z)$ is the stable size distribution

Calculate the un-corrected sensitivity of the matrix to changes in the survival function
```{r}
# after code in Ellner book
dK_by_ds_z1z <- outer (meshp, meshp, function (z1, z, paramCont) {
  GR.fun(z, z1, paramCont) * (1 - FL.fun(z, paramCont)) 
  }, 
  paramCont 
  )

## then, add a row and column of zeros to represent the seedbank %%% not sure if
# I need to do this, but I think so, otherwise the sensitivity matrix is one
# row and one column larger?
dK_by_ds_z1z <- cbind(0,rbind(0,dK_by_ds_z1z)) 
# "then, multiply this element-wise by the sensitivity function from earlier and 
# sum over the rows to do the integration, remembering to multiply by the meshpt width
s.sens.z <- apply(S * dK_by_ds_z1z, 2, sum) * h
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival and growth.

VSS for $s(z)$ = $$\frac{s(z)(1-s(z))}{\lambda} \frac{\delta\lambda}{\delta s(z)}$$
where $\frac{\delta\lambda}{\delta s(z)}$ is the sensitivity calculated above
```{r}
# VSS on survival 
# first, add a '0' to the beginning of the surv.mu and surv.sd vectors (for the seedbank, which doesn't 'survive')
surv.mu <- c(0,surv.mu) 
surv.sd <- c(0, surv.sd) #(we'll use this later for the vr buffering analysis)

# calculate VSS 
VSS.surv <- s.sens.z * ((surv.mu*(1-surv.mu))/lambda)

# compare VSS of survival to un-corrected sensitivity to survival (the dashed line is the VSS)
plot(s.sens.z,type = "l")
lines(VSS.surv, lty = 2)
```

#### Sensitivity to Flowering probability $P_b(z)$
Based on code and details from the Ellner, Childs and Rees book
** I'm really not sure about this one, because it includes the seedbank, and also parameters that are discrete, so don't need to be integrated??

Function: $$\frac{\delta\lambda}{\delta P_b(z_0)} = \frac{\int v(z')[goCont(b(z_o)c_o(z_o')) + goSB(b(z_o))]w(z)dz'}{\int v(z)w(z)dz}$$
, where $v(z)$ is the reproductive value distribution and $w(z)$ is the stable size distribution

Calculate the un-corrected sensitivity of the matrix to changes in the flowering prob. function
```{r}
# after code in Ellner book
# the first part, b(z)co(z), without the multiplcation by the discrete parameter
dK_by_dPb_z1z_part1 <- outer (meshp, meshp, 
                        function (z1, z, paramCont) {
  SDP.fun(z, paramCont) * SDS.fun(z1, paramCont) 
  }, 
  paramCont 
  )

## then, add a row and column of zeros to represent the seedbank %%% not sure if
# I need to do this, but I think so, otherwise the sensitivity matrix is one
# row and one column larger?
dK_by_dPb_z1z_part1 <- cbind(0,rbind(0,dK_by_dPb_z1z_part1))

# multiply by the sensitivity and sum across rows to do the integration, then multiply by the discrete parameter, goCont
Pb.sens_part1 <- goCont * apply(S *  dK_by_dPb_z1z_part1, 2, sum) * h

# then, do the calculation for the sensitivity of the seedbank state to flowering probability
dK_by_dPb_z1z_part2 <- outer(meshp, meshp, 
                              function(z1, z, paramCont) {SDP.fun(z, paramCont) },
                              paramCont
                              )

## then, add a row and column of zeros to represent the seedbank %%% not sure if
# I need to do this, but I think so, otherwise the sensitivity matrix is one
# row and one column larger?
dK_by_dPb_z1z_part2 <- cbind(0,rbind(dK_by_dPb_z1z_part2[1,],dK_by_dPb_z1z_part2))


# multiply by the sensitivity and sum across rows to do the integration, then multiply by the discrete parameter, goCont
Pb.sens_part2 <- goSB* apply(S * dK_by_dPb_z1z_part2, 2, sum) * h

# Then, add the sensitivities together?? I'm really not sure if this is correct?
Pb.sens.z <- Pb.sens_part1 + Pb.sens_part2
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{Pb(z)(1-Pb(z))}{\lambda} \frac{\delta\lambda}{\delta Pb(z)}$$
where $\frac{\delta\lambda}{\delta Pb(z)}$ is the sensitivity calculated above
```{r}
# VSS on flowering probability 

# calculate VSS 
VSS.flwr <- Pb.sens.z * ((flowering.mu*(1-flowering.mu))/lambda)
# this is a matrix... is this correct? 
```

#### Sensitivity to Seed production  $P_b(z)$
Based on code and details from the Ellner, Childs and Rees book
** I'm really not sure about this one, because it includes the seedbank, and also parameters that are discrete, so don't need to be integrated??

Function: $$\frac{\delta\lambda}{\delta b(z_0)} = \frac{\int v(z')[goCont(Pb(z_o)c_o(z_o')) + goSB(Pb(z_o))]w(z)dz'}{\int v(z)w(z)dz}$$
, where $v(z)$ is the reproductive value distribution and $w(z)$ is the stable size distribution

Calculate the un-corrected sensitivity of the matrix to changes in the Seed production  function
```{r}
# after code in Ellner book
# the first part, b(z)co(z), without the multiplcation by the discrete parameter
dK_by_db_z1z_part1 <- outer (meshp, meshp, 
                        function (z1, z, paramCont) {
  FL.fun(z, paramCont) * SDS.fun(z1, paramCont) 
  }, 
  paramCont 
  )

## then, add a row and column of zeros to represent the seedbank %%% not sure if
# I need to do this, but I think so, otherwise the sensitivity matrix is one
# row and one column larger?
dK_by_db_z1z_part1 <- cbind(0,rbind(0,dK_by_db_z1z_part1))

# multiply by the sensitivity and sum across rows to do the integration, then multiply by the discrete parameter, goCont
b.sens_part1 <- goCont * apply(S *  dK_by_db_z1z_part1, 2, sum) * h

# then, do the calculation for the sensitivity of the seedbank state to Seed production 
dK_by_db_z1z_part2 <- outer(meshp, meshp, 
                              function(z1, z, paramCont) {
                                FL.fun(z, paramCont) 
                                },
                              paramCont
                              )

## then, add a row and column of zeros to represent the seedbank %%% not sure if
# I need to do this, but I think so, otherwise the sensitivity matrix is one
# row and one column larger?
dK_by_db_z1z_part2 <- cbind(0,rbind(dK_by_db_z1z_part2[1,],dK_by_db_z1z_part2))


# multiply by the sensitivity and sum across rows to do the integration, then multiply by the discrete parameter, goCont
b.sens_part2 <- goSB* apply(S * dK_by_db_z1z_part2, 2, sum) * h

# Then, add the sensitivities together?? I'm really not sure if this is correct?
b.sens.z <- b.sens_part1 + b.sens_part2
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. Because this is a number (not a probability), the VSS corresponds to the elasticity, which is found by scaling the sensitivity function by (survival / lambda): 

Elasticity for $s(z)$ = $$\frac{\delta \lambda}{\delta b(z)} * \frac{b(z)}{\lambda} $$
where $\frac{\delta\lambda}{\delta Pb(z)}$ is the sensitivity calculated above
```{r}
# VSS on Seed production  

# calculate VSS 
VSS.seeds <- b.sens.z * c(0,SDP.fun(meshp, paramCont))/lambda
# compare to untransformed sensitivity
plot(VSS.seeds, type = "l")
lines(b.sens.z, lty = 2)
```

#### Sensitivity to growth probability $G(z',z)$
Based on code and details from the Ellner, Childs and Rees book (with no integrals, because the growth function results in a matrix?)

Function: $$\frac{\delta\lambda}{\delta G(z_o',z_o)} = \frac{v(z')(1-Pb(z_o))s(z_o) w(z)}{v(z)w(z)}$$
, where $v(z)$ is the reproductive value distribution and $w(z)$ is the stable size distribution

Calculate the un-corrected sensitivity of the matrix to changes in the growth prob. function
```{r}
# after code in Ellner book
# the first part, b(z)co(z), without the multiplcation by the discrete parameter
dK_by_dG_z1z <- outer (meshp, meshp, 
                        function (z1, z, paramCont) {
  (1 - FL.fun(z, paramCont)) * S.fun(z, paramCont) 
  }, 
  paramCont 
  )

## then, add a row and column of zeros to represent the seedbank %%% not sure if
# I need to do this, but I think so, otherwise the sensitivity matrix is one
# row and one column larger?
dK_by_dG_z1z <- cbind(0,rbind(0,dK_by_dG_z1z))

# multiply by the sensitivity
G.sens.z1z <-S *  dK_by_dG_z1z
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $G(z',z)$ = $$\frac{G(z',z)(1-G(z',z))}{\lambda} \frac{\delta\lambda}{\delta G(z',z)}$$
where $\frac{\delta\lambda}{\delta Pb(z)}$ is the sensitivity calculated above
```{r}
# VSS on growth probability 

# calculate VSS 
VSS.growth <- G.sens.z1z[2:501,2:501] * ((growth.mean*(1-growth.mean))/lambda)
```


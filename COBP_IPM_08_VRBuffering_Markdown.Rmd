---
title: "Integral Projection Models for *Oenothera coloradensis*: Analysis of Vital Rate Buffering"
author: "Alice Stears"
date: "2023-05-16"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(popbio)
```

## IPM Equations

#### continuous, above-ground state:
$$ n(z',t_1) = \int^U_L [1-P_b(z)]s(z)G(z',z)n(z,t)dz + goCont \int^U_LP_b(z)b(z)c_o(z')n(z,t)dz + outSB[B(t)c_o(z')]$$     

#### discrete, seedbank state:
$$ B(t+1) = goSB \int^U_LP_b(z)b(z)n(z,t)dz + B(t)staySB$$    

where:

-   $G(z',z)$ is the distribution of plant size in year *t+1* as a
    function of size in year *t*\
-   $s(z)$ is the probability of survival based on size in year *t*\
-   $P_b(z)$ is the probability of flowering based on size in year
    *t*\
-   $b(z)$ is the number of seeds produced by a flowering plant based
    on size in year *t*\
-   $c_o(z')$ is the distribution of above-ground recruit size in
    year *t+1*        
-   $goCont$ is the discrete probability of a seed produced in year *t* germinating as a seedling in year *t+1*       
-   $outSB$ is the discrete probability of a seed from the sandbank in year *t* germinating as a seedling in year *t+1*       
-   $goSB$ is the discrete probability of a seed produced in year *t* going to the sandbank in year *t+1*       
-   $staySB$ is the discrete probability of a sandbank seed in year *t* persisting in the sandbank in year *t+1*        

## Prepare to make IPMs

#### load data

```{r}
# location of files
datFolder <- "~/Dropbox/Work/Grad School/Research/Oenothera coloradensis project/COBP_analysis/other_scripts/VSS_codeData/"
# load data file
dat_all <- read.csv(file = paste0(datFolder, "/allDat_plus_contSeedlings.csv"))
```

## Make IPMs 
Below is example code showing how I created an IPM for one of the six sub-populations. In this analysis, I calculated an IPM for each sub-population in each transition (a total of 12 IPMs, called IPMs CC through NN), which were used to calculate the mean and standard deviations of each vital rate. I also calculated an IPM using data from all sub-populations in both transitions, which I used to calculate sensitivity and elasticity for each vital rate. All of these IPMs used the same structure, but had different vital rate function parameters. 
```{r, eval = FALSE}
# establish upper and lower bounds of the continuous state
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum ln(size), -2.8
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum ln(size), 4.4

n <-500 # bins

# These are the parameters for the discrete stages
outSB <- outSB_all #SB to continuous stage, 0.14
staySB <- staySB_all # staying in SB, 0.75
goCont <- goCont_all # seeds become continuous right away (without going to the seed bank), 0.09
goSB <- goSB_all # seeds go to the sandbank, 0.49
surv.seeds <-  0.9 # survival of seeds

## make an IPM for the "Crow Creek" site in the 2019-2020 transition
i <- 1
  ## get data for this 'current' site
  dat_now <- dat_all[dat_all$Site == unique(dat_all$Site)[i] # data for this site
                     & dat_all$Year == 2019# data for this year
                     ,]
  
  ## fit vital rate models
  ## Survival ($s(z)$)
  survDat_now <- dat_now[dat_now$flowering==0 | is.na(dat_now$flowering),]
  survMod_now <- glm(survives_tplus1 ~ log_LL_t , data = survDat_now, family = binomial)
  ## Growth ($G(z',z)$)
  sizeMod_now <- lm(log_LL_tplus1 ~ log_LL_t , data = dat_now)
  ## Number of seeds produced, according to plant size ($b(z)$)
  seedDat_now <- dat_now[dat_now$flowering==1,]
  # fit poisson glm (for count data)
  seedMod_now <- MASS::glm.nb(Num_seeds ~ log_LL_t , data = seedDat_now)
  ## Flowering probability ($p_b(z)$)
  flwrMod_now <- suppressWarnings((glm(flowering ~ log_LL_t + I(log_LL_t^2) , data = dat_now, family = binomial)))
  ## Distribution of recruit size ($c_o(z')$)
  # subset the data
  recD_now <- dat_all[dat_all$seedling == 1 & dat_all$Year == 2020,]
  # fit the model
  recMod_now <- lm(log_LL_t ~ 1, data = recD_now)
  
  ## put in the parameter list (paramCont)
  paramCont <- list(
    g_int     = coef(sizeMod_now)[1], # growth 
    g_slope   = coef(sizeMod_now)[2],
    g_sd      = summary(sizeMod_now)$sigma,
    s_int     = coef(survMod_now)[1], # survival
    s_slope   = coef(survMod_now)[2],
    p_b_int   = coef(flwrMod_now)[1], #probability of flowering
    p_b_slope = coef(flwrMod_now)[2],
    p_b_slope_2 = coef(flwrMod_now)[3],
    b_int   = coef(seedMod_now)[1], #seed production
    b_slope = coef(seedMod_now)[2],
    c_o_mu    = coef(recMod_now), #recruit size distribution
    c_o_sd    = summary(recMod_now)$sigma,
    outSB  = outSB_all,
    staySB = staySB_all,
    goSB   = goSB_all, 
    goCont = goCont_all                  
  )
  ## make vital rate functions for the IPM
  # SURVIVAL:
  S.fun <- function(z, paramCont) {
    mu.surv=paramCont$s_int + paramCont$s_slope *z
    return(1/(1 + exp(-(mu.surv))))
  }
  # GROWTH (we assume a constant variance)
  GR.fun <- function(z,zz, paramCont){
    growth.mu = paramCont$g_int + paramCont$g_slope*z
    return(dnorm(zz, mean = growth.mu, sd = paramCont$g_sd))
  }
  ## SEEDLING SIZES (same approach as in growth function)
  SDS.fun <- function(zz, paramCont){
    rec_mu <- paramCont$c_o_mu
    rec_sd <- paramCont$c_o_sd
    return(dnorm(zz, mean = rec_mu, sd = rec_sd))
  }
  # PROBABILITY OF FLOWERING 
  FL.fun <- function(z, paramCont) {
    mu.fl = paramCont$p_b_int + paramCont$p_b_slope*z +  paramCont$p_b_slope_2 * (z^2)
    return(1/(1+ exp(-(mu.fl))))
  }
  # SEED PRODUCTION
  SDP.fun <- function(z, paramCont) {
    mu.fps=exp(paramCont$b_int + paramCont$b_slope *z)
    return(mu.fps)
  }
  
  ## fit the IPM
  K <- array(0,c(n+1,n+1))
  # Setting up the kernels
  b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
  meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
  h=(U-L)/n # bin width 
  # Survival and growth 
  S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
  G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth
  # G <- t(outer(meshp,meshp,GR.fun)) # Growth
  #Recruits distribution (seeds recruited from the sandbank into the continuous stage)
  c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)
  # c_o <- matrix(rep(SDS.fun(meshp),n),n,n,byrow=F)
  #Probability of flowering
  Pb = (FL.fun(meshp, paramCont))
  #Number of seeds produced according to adult size
  b_seed = (SDP.fun(meshp, paramCont))
  FecALL= Pb * b_seed
  # update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
  S_new <- S * (1-Pb)
  # Control for eviction:
  # this is equivalent to redistributing evicted sizes evenly among existing size classes 
  G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
  c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)
  # make the continuous part of the P matrix
  Pkernel.cont <- as.matrix(G %*% S_new)
  # sandbank (first column of your K)
  Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous
  # Make the full P kernel
  Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component
  ## make the F kernel
  Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class
  Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)
  Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))
  
  mat <-Pkernel+Fkernel
  
  eigenMat <- eigen(mat)
  
  IPMs_II_NN[[i]] <- list(KMatrix = mat,
                          GMatrix = G, 
                          SMatrix = S_new,
                          FMatrix = Fkernel.cont,
                          staySB_vec = staySB, 
                          leaveSB_vec = as.matrix((outSB*c_o[,1]), nrow = 500, ncol = 1), 
                          goSB_vec = matrix(c( goSB * (FecALL)), nrow = 1),
                          params = paramCont)

```
#### To save time, we can load the saved IPMs that were calculated previously
```{r, message=FALSE}
# sub population-level, each transition IPMs
IPMs_CC_HH <- readRDS(paste0(datFolder,"IPMs_CC_HH.RDS"))
IPMs_II_NN <- readRDS(paste0(datFolder,"IPMs_II_NN.RDS"))
# all populations, all transitions IPM
load(paste0(datFolder,"ipmA_B_results.RData"))
```

## Calculate mean and corrected standard deviation of Vital Rates
#### * Based on the VSS code for matrix models that Maria Paniw shared

Put all of the IPMs for each sub population/transition into one big list
```{r}
allIPMs <- c(IPMs_II_NN, IPMs_CC_HH)

# also define the vector of meshpoints that is used to make each IPM (which we'll need to calculate vital rate functions in the IPM)
n <- 500
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum ln(size), -2.8
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum ln(size), 4.4
# calculate the meshpoints
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)])
# calculate the binwidth
h <- diff(meshp)[1]
```

In this section we first extract the underlying vital rates, to then calculate their corrected standard deviation (according to McDonald et al. 2017). The corrections are required because we want to be able to include in the same analysis vital rates such as survival and growth (bounded between 0 and 1) and fecundity (bounded only by 0). The variance of 0-1 vital rates is constrained by a lower and upper limit, therefore these vital rates have to be transformed to free variance from this constraint.

#### Survival ($s(z)$) 
Use the survival function w/ parameters for each IPM to calculate the survival vector for each IPM (want just survival, not survival - probability of flowering)
```{r}
# survival function from the IPM
S.fun <- function(z, paramCont) {
  mu.surv=paramCont$s_int + paramCont$s_slope *z 
  return(1/(1 +exp(-(mu.surv)))) }
# calculate the survival probability based on model parameters for each IPM
# surv is a matrix with 500 rows (one for each meshpoint) and 12 columns (one for each subpop/year)
surv <- sapply(allIPMs, FUN = function(x) 
  S.fun(z =
meshp, paramCont = x$params) )

#Get the mean survival vector over all 12 IPMs (surv.mu is a vector with the mean survival rate for each cell of the IPM)
surv.mu <- apply(surv, 1, mean)

#Get the standard deviation of survival over all of the IPMs
surv.sd <- apply(surv, 1, sd)

# get the corrected sd (use a logit transformation, since it is a probability)
# (McDonald et al. (2017) used logit transformation on 0-1 vital rates)
corr.surv.sd <- apply(car::logit(surv,adjust = 0.001), 1 ,sd)
```

#### Probability of Flowering $(P_b(z))$

Use the flowering function w/ parameters for each IPM to calculate the P(flowering) vector for each IPM
```{r}
# PROBABILITY OF FLOWERING
FL.fun <- function(z, paramCont) { 
  mu.fl = paramCont$p_b_int + paramCont$p_b_slope*z + paramCont$p_b_slope_2* (z^2) 
  return(1/(1+ exp(-(mu.fl)))) }

# calculate the flowering probability based on model parameters for each IPM
flowering <- sapply(allIPMs, 
                    FUN = function(x) 
  FL.fun(z = meshp, paramCont = x$params) 
  ) 
# at this point, 'flowering' is a list where each list element is for a subpop/year, and contains a vector of flowering probabilities

# Now, calculate the mean flowering probability
# get a matrix that is an average of all of the different Fmats from each IPM 
flowering.mu <- apply(flowering, 1, mean) 

# sd of fecundity 
flowering.sd <- apply(flowering, 1, sd) 

# get the corrected sd (use a logit transformation, since it is a probability) McDonald et al. (2017) used logit transformation on 0-1 vital rates
corr.flowering.sd <- apply(car::logit(flowering,adjust = 0.001), 1,sd) 
```


#### Seed production ($b(z)$)

Use the seed production function w/ parameters for each IPM to calculate the seed production vector for each IPM
```{r}
# SEED PRODUCTION
SDP.fun <- function(z, paramCont) {
  mu.fps = exp(paramCont$b_int + paramCont$b_slope * z)
  return(mu.fps)
}

# calculate seed production based on model parameters for each IPM
seedProd <- sapply(
  allIPMs,
  FUN = function(x)
    SDP.fun(z = meshp, paramCont = x$params)
)


# are there any values of 0 in the seed production vectors?
sum(unlist(lapply(seedProd, FUN = function(x) sum(x==0))) >0)

# Since the correction that we must apply to fecundities is the
# log-transformation, we encounter problems when the the vital rate has a value
# of 0. The following if-else loops are needed to deal with fecundity matrices
# with "0" entries where they should have a positive value (0s are a problem
# because log transformation can't be done on the value "0"). Therefore, we add
# a small value (0.01) to the fecundity value which is 0, over all the years of
# the study. This way, we keep a biological meaning, and we stay consistent.

seedProd <- apply(
  X = seedProd,
  MARGIN = 2,
  FUN =
    function(x)
      replace(x, list = which(x == 0, arr.ind = TRUE), values =
                .0001)
) 

#Now, calculate mean seedProd probability
seedProd.mu <- apply(simplify2array(seedProd), 1, mean) 
# this is a matrix that is an average of all of the different seed production matrices from each IPM 

# plot(seedProd.mu, type = "l", ylim = c(0,13000), lwd = 2)
# lines(seedProd[,1], lty = 2)
# lines(seedProd[,2], lty = 2)
# lines(seedProd[,3], lty = 2)
# lines(seedProd[,4], lty = 2)
# lines(seedProd[,5], lty = 2)
# lines(seedProd[,6], lty = 2)
# lines(seedProd[,7], lty = 2)
# lines(seedProd[,8], lty = 2)
# lines(seedProd[,9], lty = 2)
# lines(seedProd[,10], lty = 2)
# lines(seedProd[,11], lty = 2)
# lines(seedProd[,12], lty = 2)

# sd of seed production 
seedProd.sd <- apply(simplify2array(seedProd), 1, sd)

# get the corrected sd (use a log transformation, since it is NOT a probability) 
corr.seedProd.sd <- apply(log(simplify2array(seedProd)), 1 ,sd) 
```

#### Growth $G(z',z)$
Use the growth function w/ parameters for each IPM to calculate the growth for each IPM
```{r}
# GROWTH (we assume a constant variance)
GR.fun <- function(z, zz, paramCont) {
  growth.mu =
    paramCont$g_int + paramCont$g_slope * z 
  return(dnorm(zz, mean = growth.mu, 
               sd =  paramCont$g_sd))
} 

# calculate the growth matrix based on model parameters for each IPM
growth <-
  lapply(allIPMs,
    FUN = function(x)
      #h * GR.fun(z = meshp, zz = meshp, paramCont = x$params)
      h * t(outer(meshp, meshp, GR.fun, paramCont = x$params) ## don't multiply by h (integrate)...should I???
            )
    ) 
# 'growth' is a list in which each element contains the growth matrix for one subpop/year
    
#Calculate the mean of growth 
growth.mean <-
    apply(simplify2array(growth), 1:2, mean) 
#growth.mean <- apply(simplify2array(growth), 1, mean)

# sd of growth
growth.sd <-
  apply(simplify2array(growth), 1:2, sd) 
#growth.sd <- apply(simplify2array(growth), 1, sd)

# corrected sd of growth (use a logit transformation, since it is a probability)
corr.growth.sd <-
  apply(car::logit(simplify2array(growth),adjust = .001), 1:2, sd)
```

#### seedling size distribution $c_0(z)$
Use the seedling size distribution function w/ parameters for each IPM to calculate the growth for each IPM
```{r}
 ## SEEDLING SIZES (same approach as in growth function)
  SDS.fun <- function(zz, paramCont){
    rec_mu <- paramCont$c_o_mu
    rec_sd <- paramCont$c_o_sd
    return(dnorm(zz, mean = rec_mu, sd = rec_sd))
  }
# calculate the growth matrix based on model parameters for each IPM
seedlingSize <-
  lapply(allIPMs,
    FUN = function(x)
      #h * SDS.fun(zz = meshp, paramCont = x$params) 
    h * matrix(rep(SDS.fun(meshp, x$params),n),n,n,byrow=F)
      ) 
# 'seedling size' is a list in which each element contains the growth matrix for one subpop/year
    
#Calculate the mean of seedling size
seedlingSize.mean <-
    apply(simplify2array(seedlingSize), 1:2, mean) 
#seedlingSize.mean <- apply(simplify2array(seedlingSize), 1, mean)

# sd of SeedlingSize 
seedlingSize.sd <-
    apply(simplify2array(seedlingSize), 1:2, sd) 
#seedlingSize.sd <- apply(simplify2array(seedlingSize), 1, sd)
 
# corrected sd of SeedlingSize (use a logit transformation, since it is a probability)
corr.seedlingSize.sd <-
  apply(car::logit(simplify2array(seedlingSize),adjust = .001), 1:2, sd)
```

#### We don't calculate mean for seedbank parameters and seedling size distribution, because those values were calculated at the population level (so there is no variation accross subpopulations). We simulate standard deviation for these vital rates as the maximum possible? %%% not too sure about this

First, simulate the maximum standard deviation for each sandbank vital rate 

```{r}
corr.outSB.sd <- sd(car::logit(seq(from = .01, to = .99, length.out = 100)))
corr.staySB.sd <- sd(car::logit(seq(from = .01, to = .99, length.out = 100)))
corr.goCont.sd <- sd(car::logit(seq(from = .01, to = .99, length.out = 100)))
corr.goSB.sd <- sd(car::logit(seq(from = .01, to = .99, length.out = 100)))
```

Then, simulate the minimum standard deviation for each sandbank vital rate 
```{r}
corr.outSB.sd_min <- sd(car::logit(seq(from = (outSB-.01), to =( outSB+.01), length.out = 100)))
corr.staySB.sd_min <- sd(car::logit(seq(from = (staySB-.01), to = (staySB+.01), length.out = 100)))
corr.goCont.sd_min <- sd(car::logit(seq(from = (goCont-.01), to = (goCont+.01), length.out = 100)))
corr.goSB.sd_min <- sd(car::logit(seq(from = (goSB-.01), to = (goSB+.01), length.out = 100)))
```

## Calculate Sensitivity 

Calculate the sensitivity of each vital rate using the "Brute Force Method." 
Then, we calculate the corrected sensitivity for each rate according to McDonald et al. (2017)

We calculate the vital rate sensitivities based on the matrix from IPM B (called "mat_all_DI") (IPM for all sites and both transitions) (I think this is correct? not too sure? Should I calculate it from the mean matrix from all 12 subpop/year IPMs instead?)

#### Preparation

First, get parameter values used to make the all pops, all transitions IPM, and save in a list
```{r}
# Empty list to save model coefficients 
paramCont=list(NULL)
# survival model is called 'survMod_all'
paramCont[[1]]=as.matrix(coef(survMod_all)) # save coefficients 
# growth model is called 'sizeMod_all'
paramCont[[2]]=cbind(as.matrix(coef(sizeMod_all)),sd(residuals(sizeMod_all))) # the third column is for the standard deviation of growth 
# seedling size distribution is a uniform distribution (of exp(size_2)) with a min of 0.1 and a max 0f 3
paramCont[[3]]= cbind(as.matrix(coef(recMod_all)), sd(residuals(recMod_all)))
# model for probability of flowering is flwrMod_all
paramCont[[4]]=as.matrix(coef(flwrMod_all))
# model for seed production per plant (if reproductive) is seedMod_all
paramCont[[5]]=as.matrix(coef(seedMod_all))
# name the paramCont list to keep track of coefficients
names(paramCont) <- c("survival", "growth", "recruitDist", "flowering", "seedProduction")

```

These are the parameters for the discrete stages
```{r}
outSB <- outSB_all #SB to continuous stage
staySB <- staySB_all # staying in SB
goCont <- goCont_all # seeds become continuous right away (without going to the seed bank) 
goSB <- goSB_all # seeds go to the sandbank
surv.seeds <-  0.9 # survival of seeds
```

Define starting conditions for the IPMs
```{r}
# Define the lower and upper integration limit
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum size
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum size

n <-500 # bins
```


Then, define the vital rate functions that are used to make the IPM (Same as the functions used to calculate mean and sd vital rate parameter values above)
```{r}
# SURVIVAL:
S.fun <- function(z, paramCont) {
  mu.surv=paramCont[["survival"]]["(Intercept)",] + paramCont[["survival"]]["log_LL_t",]*z
  return(1/(1 + exp(-(mu.surv))))
}
# GROWTH (we assume a constant variance)
GR.fun <- function(z,zz, paramCont){
  growth.mu = paramCont[["growth"]]["(Intercept)",1] + paramCont[["growth"]]["log_LL_t",1]*z
  return(dnorm(zz, mean = growth.mu, sd = paramCont[["growth"]][1,2]))
}
## SEEDLING SIZES (same approach as in growth function)
SDS.fun <- function(zz, paramCont){
  rec_mu <- paramCont[["recruitDist"]][1]
  rec_sd <- paramCont[["recruitDist"]][2]
  return(dnorm(zz, mean = rec_mu, sd = rec_sd))
}
# PROBABILITY OF FLOWERING 
FL.fun <- function(z, paramCont) {
  mu.fl = paramCont[["flowering"]][1,] + paramCont[["flowering"]][2,]*z +  paramCont[["flowering"]][3,]* (z^2)
  return(1/(1+ exp(-(mu.fl))))
}
# SEED PRODUCTION
SDP.fun <- function(z, paramCont) {
  mu.fps=exp(paramCont[["seedProduction"]][1,1] + paramCont[["seedProduction"]][2,1]*z)
  return(mu.fps)
}
```

Save the lambda and vital rate function values from the unperturbed IPM
```{r}
# lambda value
lambda_OG <- lam_all_DI

## vital rate functions
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width  

# survival
surv_OG <- S.fun(meshp, paramCont)
  
# growth
growth_OG <- #h * GR.fun(z = meshp, zz = meshp, paramCont = paramCont) # don't multiply by h... so no integration? is this correct?
  h * t(outer(meshp,meshp,GR.fun, paramCont))

# seedling size distribution
seedlingSize_OG <-  #h * SDS.fun(zz = meshp, paramCont = paramCont)
  h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

# probability of flowering
flowering_OG <- (FL.fun(meshp, paramCont))

# numbers of seeds produced 
seedProd_OG <- (SDP.fun(meshp, paramCont))
```

#### Sensitivity to Survival $s(z)$    
Calculate the un-corrected sensitivity of the IPM matrix to changes in the survival function by calculating the IPM matrix with slightly perturbed survival function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- 0.05

## redefine the survival function to add a tiny value 
S.fun_pert <- function(z, paramCont) {
  mu.surv=paramCont[["survival"]]["(Intercept)",] + paramCont[["survival"]]["log_LL_t",]*z 
  return(1/(1 + exp(-(mu.surv))) + perturbVal)
}
# Survival and growth 
S<- diag(S.fun_pert(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth
# G <- t(outer(meshp,meshp,GR.fun)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)
# c_o <- matrix(rep(SDS.fun(meshp),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_Survival <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_Survival)
# get and save the perturbed lambda
lambda_perturb_Survival <-eigenMat$values[1]
# get and save the perturbed vital rate function
s_perturb <- S.fun_pert(meshp, paramCont)
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{s(z)} = \frac{\Delta\lambda}{\Delta s(z)} = \frac{\lambda_{perturb} - \lambda_{original}}{s(z)_{perturb} - s(z)_{original}}$$
```{r}
sens_Surv <- as.numeric(lambda_perturb_Survival - lambda_OG) / (s_perturb - surv_OG)

plot(sens_Surv, type = "l")
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival and growth.

VSS for $s(z)$ = $$\frac{s(z)(1-s(z))}{\lambda} \frac{\delta\lambda}{\delta s(z)}$$
where $\frac{\delta\lambda}{\delta s(z)}$ is the sensitivity calculated above
```{r}
# VSS on survival 
# first, add a '0' to the beginning of the surv.mu and surv.sd vectors (for the sandbank, which doesn't 'survive')
# called "surv.mu" and "surv.sd" #(we'll use this later for the vr buffering analysis)

# calculate VSS 
VSS.surv <- as.numeric(sens_Surv * ((surv.mu*(1-surv.mu))/lambda_OG))

# compare VSS of survival to un-corrected sensitivity to survival (the dashed line is the VSS)
plot(sens_Surv,type = "l", ylim = c(0,2.6))
lines(VSS.surv, lty = 2)
```

#### Sensitivity to Flowering probability $P_b(z)$
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the flowering function by calculating the IPM matrix with slightly perturbed flowering function 
%%% I'm really not sure where I should add the perturbation to this function? Based on example code from Levin ESA workshop, added it after the logit transformation??
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- 0.005

## redefine the flowering probability function to add a tiny value 
# PROBABILITY OF FLOWERING 
FL.fun_pert <- function(z, paramCont) {
  mu.fl = paramCont[["flowering"]][1,] + paramCont[["flowering"]][2,]*z +  paramCont[["flowering"]][3,]* (z^2) 
  return(1/(1+ exp(-(mu.fl))) + perturbVal)
}
# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth
# G <- t(outer(meshp,meshp,GR.fun)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)
# c_o <- matrix(rep(SDS.fun(meshp),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun_pert(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_Flowering <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_Flowering)
# get and save the perturbed lambda
lambda_perturb_Flowering <-eigenMat$values[1]
# get and save the perturbed vital rate function
Pb_perturb <- FL.fun_pert(meshp, paramCont)
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{Pb(z)} = \frac{\Delta\lambda}{\Delta Pb(z)} = \frac{\lambda_{perturb} - \lambda_{original}}{Pb(z)_{perturb} - Pb(z)_{original}}$$
```{r}
sens_Flowering <- as.numeric(lambda_perturb_Flowering - lambda_OG) / (Pb_perturb - flowering_OG)

plot(sens_Flowering, type = "l")
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{Pb(z)(1-Pb(z))}{\lambda} \frac{\delta\lambda}{\delta Pb(z)}$$
where $\frac{\delta\lambda}{\delta Pb(z)}$ is the sensitivity calculated above
```{r}
# VSS on flowering probability 

# calculate VSS 
VSS.flwr <- as.numeric(sens_Flowering * ((flowering.mu*(1-flowering.mu))/lambda_OG))

# compare VSS of flowering to un-corrected sensitivity to flowering (the dashed line is the VSS)
  plot(sens_Flowering,type = "l",ylim = c(0,7)
       )
lines(VSS.flwr, lty = 2)
```

#### Sensitivity to Seed production  $P_b(z)$
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the seed production function by calculating the IPM matrix with slightly perturbed seed production function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- 6

## redefine the seed production function to add a tiny value 
# SEED PRODUCTION
SDP.fun_pert <- function(z, paramCont) {
  mu.fps=exp(paramCont[["seedProduction"]][1,1] + paramCont[["seedProduction"]][2,1]*z)  
  return(mu.fps + perturbVal)
}

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun_pert(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_SeedProd <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_SeedProd)
# get and save the perturbed lambda
lambda_perturb_SeedProd <-eigenMat$values[1]
# get and save the perturbed vital rate function
b_perturb <- SDP.fun_pert(meshp, paramCont)
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{b(z)} = \frac{\Delta\lambda}{\Delta b(z)} = \frac{\lambda_{perturb} - \lambda_{original}}{b(z)_{perturb} - b(z)_{original}}$$
```{r}
sens_SeedProd <- as.numeric(lambda_perturb_SeedProd - lambda_OG) / (b_perturb - seedProd_OG)

plot(sens_SeedProd, type = "l", ylim = c(0, .005))
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. Because this is a number (not a probability), the VSS corresponds to the elasticity, which is found by scaling the sensitivity function by (survival / lambda): 

Elasticity for $b(z)$ = $$\frac{\delta \lambda}{\delta b(z)} * \frac{b(z)}{\lambda} $$
where $\frac{\delta\lambda}{\delta b(z)}$ is the sensitivity calculated above
```{r}
# VSS on Seed production  

# calculate VSS 
VSS.seeds <- sens_SeedProd * (SDP.fun(meshp, paramCont)/as.numeric(lambda_OG))

# compare to untransformed sensitivity
plot(sens_SeedProd, type = "l", ylim = c(0, 4.5))
lines(VSS.seeds, lty = 2)
```

#### Sensitivity to growth probability $G(z',z)$
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the growth probability function by calculating the IPM matrix with slightly perturbed growth probability function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- .01

## redefine the growth probability function to add a tiny value 
  # GROWTH (we assume a constant variance)
GR.fun_pert <- function(z,zz, paramCont){
  growth.mu = paramCont[["growth"]]["(Intercept)",1] + paramCont[["growth"]]["log_LL_t",1]*z 
  return(dnorm(zz, mean = growth.mu, sd = paramCont[["growth"]][1,2]) + perturbVal)
}

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun_pert, paramCont)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_Growth <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_Growth)
# get and save the perturbed lambda
lambda_perturb_Growth <-eigenMat$values[1]
# get and save the perturbed vital rate function
G_perturb <- h * t(outer(meshp,meshp,GR.fun_pert, paramCont))
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{G(z',z)} = \frac{\Delta\lambda}{\Delta G(z',z)} = \frac{\lambda_{perturb} - \lambda_{original}}{G(z',z)_{perturb} - G(z',z)_{original}}$$
```{r}
sens_Growth <- as.numeric(lambda_perturb_Growth - lambda_OG) / (G_perturb - growth_OG)

#image(sens_Growth)
```


Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{G(z',z)(1-G(z',z))}{\lambda} \frac{\delta\lambda}{\delta G(z',z)}$$

where $\frac{\delta\lambda}{\delta G(z',z)}$ is the sensitivity calculated above
```{r}
# VSS on growth ≈

# calculate VSS 
# version for non-probability vital rate
# VSS.growth <- sens_Growth * (growth_OG/as.numeric(lambda_OG))
# version for probability vital rate
VSS.growth <- as.numeric(sens_Growth) * ((growth.mean*(1-growth.mean))/ as.numeric(lambda_OG))

#plot(VSS.growth, type = "l")
#lines(sens_Growth, lty = 2)
```

#### Sensitivity to seedling recruit size
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the growth probability function by calculating the IPM matrix with slightly perturbed seedling recruit size probability function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- .01

## redefine the recruit size probability distribution 
## SEEDLING SIZES (same approach as in growth function)
SDS.fun_pert <- function(zz, paramCont){
  rec_mu <- paramCont[["recruitDist"]][1] 
  rec_sd <- paramCont[["recruitDist"]][2]
  return(dnorm(zz, mean = rec_mu, sd = rec_sd)+ perturbVal)
}

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun_pert(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_SeedlingSize <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_SeedlingSize)
# get and save the perturbed lambda
lambda_perturb_SeedlingSize <-eigenMat$values[1]
# get and save the perturbed vital rate function
c_o_perturb <- h * SDS.fun_pert(zz = meshp, paramCont = paramCont) 
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{c_0(z)} = \frac{\Delta\lambda}{\Delta c_0(z)} = \frac{\lambda_{perturb} - \lambda_{original}}{c_0(z)_{perturb} - c_0(z)_{original}}$$
```{r}
sens_SeedlingSize <- as.numeric(lambda_perturb_SeedlingSize - lambda_OG) / (c_o_perturb - seedlingSize_OG)

#image(sens_Growth)
```
Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{c_0(z)(1-c_0(z))}{\lambda} \frac{\delta\lambda}{\delta c_0(z)}$$

where $\frac{\delta\lambda}{\delta c_0(z)}$ is the sensitivity calculated above
```{r}
# VSS on SeedlingSize 
VSS.SeedlingSize <- as.numeric(sens_SeedlingSize) * ((seedlingSize.mean*(1-seedlingSize.mean))/as.numeric(lambda_OG))

plot(VSS.SeedlingSize, type = "l")
lines(sens_SeedlingSize, lty = 2)
```

#### Sensitivity to probability of leaving the seedbank
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the outSB probability function by calculating the IPM matrix with slightly perturbed seedling recruit size probability function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- .01

## redefine the recruit size probability distribution 
## SEEDLING SIZES (same approach as in outSB function)
outSB_perturb <- outSB + perturbVal

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB_perturb*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_outSB <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_outSB)
# get and save the perturbed lambda
lambda_perturb_outSB <-eigenMat$values[1]
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{outSB} = \frac{\Delta\lambda}{\Delta outSB} = \frac{\lambda_{perturb} - \lambda_{original}}{outSB_{perturb} - outSB_{original}}$$
```{r}
sens_outSB <- as.numeric(lambda_perturb_outSB - lambda_OG) / (outSB_perturb - outSB)

```
Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{outSB(1-outSB)}{\lambda} \frac{\delta\lambda}{\delta outSB}$$

where $\frac{\delta\lambda}{\delta c_0(z)}$ is the sensitivity calculated above
```{r}
# VSS on outSB ≈

VSS.outSB <- as.numeric(sens_outSB * ((outSB*(1-outSB))/lambda_OG))
```

#### Sensitivity to probability of staying in the seedbank
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the staySB probability function by calculating the IPM matrix with slightly perturbed seedling recruit size probability function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- .01

## redefine the recruit size probability distribution 
staySB_perturb <- staySB + perturbVal

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB_perturb, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_staySB <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_staySB)
# get and save the perturbed lambda
lambda_perturb_staySB <-eigenMat$values[1]
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{staySB} = \frac{\Delta\lambda}{\Delta staySB} = \frac{\lambda_{perturb} - \lambda_{original}}{staySB_{perturb} - staySB_{original}}$$
```{r}
sens_staySB <- as.numeric(lambda_perturb_staySB - lambda_OG) / (staySB_perturb - staySB)

```
Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{staySB(1-staySB)}{\lambda} \frac{\delta\lambda}{\delta staySB}$$

where $\frac{\delta\lambda}{\delta c_0(z)}$ is the sensitivity calculated above
```{r}
# VSS on staySB ≈

VSS.staySB <- as.numeric(sens_staySB * ((staySB*(1-staySB))/lambda_OG))
```

#### Sensitivity to probability of skipping the seedbank and going to the continuous stage
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the goCont probability function by calculating the IPM matrix with slightly perturbed seedling recruit size probability function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- .01

## redefine the recruit size probability distribution 
## SEEDLING SIZES (same approach as in outSB function)
goCont_perturb <- goCont + perturbVal

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont_perturb * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_goCont <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_goCont)
# get and save the perturbed lambda
lambda_perturb_goCont <-eigenMat$values[1]
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{goCont} = \frac{\Delta\lambda}{\Delta goCont} = \frac{\lambda_{perturb} - \lambda_{original}}{goCont_{perturb} - goCont_{original}}$$
```{r}
sens_goCont <- as.numeric(lambda_perturb_goCont - lambda_OG) / (goCont_perturb - goCont)

```
Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{goCont(1-goCont)}{\lambda} \frac{\delta\lambda}{\delta goCont}$$

where $\frac{\delta\lambda}{\delta c_0(z)}$ is the sensitivity calculated above
```{r}
# VSS on goCont

VSS.goCont <- as.numeric(sens_goCont * ((goCont*(1-goCont))/lambda_OG))
```

#### Sensitivity to probability of going into the seedbank
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the goSB probability function by calculating the IPM matrix with slightly perturbed seedling recruit size probability function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- .01

## redefine the recruit size probability distribution 
## SEEDLING SIZES (same approach as in outSB function)
goSB_perturb <- goSB + perturbVal

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth

#Recruits distribution (seeds recruited from the sandbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# sandbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB_perturb * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_goSB <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_goSB)
# get and save the perturbed lambda
lambda_perturb_goSB <-eigenMat$values[1]
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{goSB} = \frac{\Delta\lambda}{\Delta goSB} = \frac{\lambda_{perturb} - \lambda_{original}}{goSB_{perturb} - goSB_{original}}$$
```{r}
sens_goSB <- as.numeric(lambda_perturb_goSB - lambda_OG) / (goSB_perturb - goSB)

```
Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{goSB(1-goSB)}{\lambda} \frac{\delta\lambda}{\delta goSB}$$

where $\frac{\delta\lambda}{\delta c_0(z)}$ is the sensitivity calculated above
```{r}
# VSS on goSB

VSS.goSB <- as.numeric(sens_goSB * ((goSB*(1-goSB))/lambda_OG))
```

## Compare VSS and corrected standard deviation of vital rates (to look for evidence of demographic buffering hypothesis[DBH])
Support for DBH: a negative correlation between vital rate importance (VSS) and vital rate variation (corrected sd)

#### Do this for each vital rate size class (w/ the simulated *maximum* possible standard deviation for each sandbank vital rate)

```{r}

# put all the vital rates into one data.frame
bigDF <- data.frame("VitalRate" = c(rep("surv", 500), rep("seedProd", 500), rep("flowerProb", 500), rep("growth", 500), 
                                    rep("seedlingSize", 500)
                                    ),
                    "sizeClass" = rep(meshp, times = 5),
                    "VSS" = c(VSS.surv, VSS.seeds, VSS.flwr, 
                              apply(X = VSS.growth, MARGIN = 2, FUN = sum), 
                              apply(X = VSS.SeedlingSize, MARGIN = 2, FUN = sum)
                              ), 
                    "correctedSD" = c(corr.surv.sd, corr.seedProd.sd, corr.flowering.sd, 
                                   apply(X = corr.growth.sd, MARGIN = 2, FUN = sum), 
                                   apply(X = corr.seedlingSize.sd, MARGIN = 2, FUN = sum)   )
                    )

for (i in 1:500) {
  meshp_i <- unique(bigDF$sizeClass)[i]
  # calculate the correlation
  cor_temp <- cor.test(c(bigDF[bigDF$sizeClass == meshp_i, "VSS"], VSS.outSB, VSS.staySB, VSS.goCont, VSS.goSB), 
                       c(bigDF[bigDF$sizeClass == meshp_i, "correctedSD"], corr.outSB.sd, corr.staySB.sd, corr.goCont.sd, corr.goSB.sd),
                       method = "pearson")
  
  
  ggplot(data = bigDF[bigDF$sizeClass == meshp_i,]) +
    geom_point(aes(x = VSS, y = correctedSD, col = VitalRate)) +
    geom_point(data = (data.frame("VitalRate" = c("outSB", "staySB", "goCont", "goSB"),
                                  "VSS" = c(VSS.outSB, VSS.staySB, VSS.goCont, VSS.goSB),
                                  "correctedSD" = c(corr.outSB.sd_min, corr.staySB.sd_min, corr.goCont.sd_min, corr.goSB.sd_min))), aes(x = VSS, y = correctedSD)) +
    geom_smooth(aes(x = VSS, y = correctedSD), method = "lm", se = FALSE, col = "grey20") +
    theme_minimal()
  
  # save the correlation
  if (i == 1) {
    correlations <- data.frame("sizeClass" = meshp_i, "correlation" = cor_temp$estimate, "corr_pVal" = cor_temp$p.value, "corr_confIntLow" = cor_temp$conf.int[1], "corr_confIntHigh" = cor_temp$conf.int[2])
  } else {
   correlations <-  rbind(correlations, data.frame("sizeClass" = meshp_i, "correlation" = cor_temp$estimate, "corr_pVal" = cor_temp$p.value, "corr_confIntLow" = cor_temp$conf.int[1], "corr_confIntHigh" = cor_temp$conf.int[2]))
  }
}
```

```{r}
# visualize the correlation coefficients for each size class 
ggplot(data = correlations) +
  geom_ribbon(aes(ymin = corr_confIntLow, ymax = corr_confIntHigh, x = meshp), fill = "lightgrey", alpha = .5) +
  geom_point(aes(x = sizeClass, y = correlation, col = corr_pVal)) + 
  geom_point(data = correlations[correlations$corr_pVal <=.05,], aes(x = sizeClass, y = correlation), pch = 5) +
  geom_hline(aes(yintercept = 0), col = "darkgrey") +
  theme_minimal()+ 
  xlab("Size Class (ln(cm))")
```

There is not a significant correlation, either negative or positive, between vital rate VSS and corrected standard deviation in any size class (this assumes the maximum possible variation for sandbank parameters). 95% confidence intervals for the correlation estimate are shown in grey.


#### Do this for each vital rate size class (w/ the simulated *minimum* possible standard deviation for each sandbank vital rate)

```{r}

for (i in 1:500) {
  meshp_i <- unique(bigDF$sizeClass)[i]
  # calculate the correlation
  cor_temp <- cor.test(c(bigDF[bigDF$sizeClass == meshp_i, "VSS"], VSS.outSB, VSS.staySB, VSS.goCont, VSS.goSB), 
                       c(bigDF[bigDF$sizeClass == meshp_i, "correctedSD"], corr.outSB.sd_min, corr.staySB.sd_min, corr.goCont.sd_min, corr.goSB.sd_min),
                       method = "pearson")
  
  
  # ggplot(data = bigDF[bigDF$sizeClass == meshp_i,]) +
  #   geom_point(aes(x = VSS, y = correctedSD, col = VitalRate)) + 
  #   geom_point(data = (data.frame("VitalRate" = c("outSB", "staySB", "goCont", "goSB"), 
  #                                 "VSS" = c(VSS.outSB, VSS.staySB, VSS.goCont, VSS.goSB), 
  #                                 "correctedSD" = c(corr.outSB.sd, corr.staySB.sd, corr.goCont.sd, corr.goSB.sd))), aes(x = VSS, y = correctedSD)) +
  #   geom_smooth(aes(x = VSS, y = correctedSD), method = "lm", se = FALSE, col = "grey20") +
  #   theme_minimal()
  
  # save the correlation
  if (i == 1) {
    correlations_min <- data.frame("sizeClass" = meshp_i, "correlation" = cor_temp$estimate, "corr_pVal" = cor_temp$p.value, "corr_confIntLow" = cor_temp$conf.int[1], "corr_confIntHigh" = cor_temp$conf.int[2])
  } else {
   correlations_min <-  rbind(correlations_min, data.frame("sizeClass" = meshp_i, "correlation" = cor_temp$estimate, "corr_pVal" = cor_temp$p.value, "corr_confIntLow" = cor_temp$conf.int[1], "corr_confIntHigh" = cor_temp$conf.int[2]))
  }
}
```

```{r}
# visualize the correlation coefficients for each size class 
ggplot(data = correlations_min) +
  geom_ribbon(aes(ymin = corr_confIntLow, ymax = corr_confIntHigh, x = meshp), fill = "lightgrey", alpha = .5) +
  geom_point(aes(x = sizeClass, y = correlation, col = corr_pVal)) + 
  geom_point(data = correlations_min[correlations_min$corr_pVal <=.05,], aes(x = sizeClass, y = correlation), col = "red", pch = 1) +
  geom_hline(aes(yintercept = 0), col = "darkgrey") +
  theme_minimal() + 
  xlab("Size Class (ln(cm))")
```

There is no significant negative correlation between vital rate VSS and corrected standard deviation in any size class (this assumes the minimum possible variation for sandbank parameters). There is, however, a significant positive correlation between VSS and corrected SD for size classes ~350 - 400 (significant correlations shown in red). 95% confidence intervals for the correlation estimate are shown in grey. 

## Compare mean of VSS and mean of SD across all vital rates

Do the comparison using the minimumm simulated standard deviation for discrete seedbank parameters
```{r}
# calculate the mean of sd and mean of VSS for each vital rate
bigDF_minSbSd <-  bigDF %>% 
  filter(VitalRate %in% c("surv", "seedProd", "flowerProb")) %>% 
  group_by(VitalRate) %>% 
  summarize(mean_VSS = mean(VSS),
            sd_VSS = sd(VSS), 
            mean_corrSD = mean(correctedSD), 
            sd_corrSD = sd(correctedSD)) %>% 
  rbind(c("outSB", VSS.outSB, NA, corr.outSB.sd_min, NA)) %>% 
  rbind(c("staySB", VSS.staySB, NA, corr.staySB.sd_min, NA)) %>% 
  rbind(c("goCont" , VSS.goCont, NA, corr.goCont.sd_min, NA)) %>% 
  rbind(c("goSB", VSS.goSB, NA, corr.goSB.sd_min,  NA)) %>% 
  rbind(c("growth", mean(VSS.growth), sd(VSS.growth), mean(corr.growth.sd), sd(corr.growth.sd))) %>%
  rbind(c("seedlingSize", mean(VSS.SeedlingSize), sd(VSS.SeedlingSize), mean(corr.seedlingSize.sd), sd(corr.seedlingSize.sd))) %>% 
  mutate(across(!VitalRate, as.numeric)) %>% 
  left_join(data.frame("VitalRate" = c("flowerProb", "seedProd", "surv", "outSB", "staySB","goCont", "goSB", "growth", "seedlingSize"), "VitalRateType" = c("continous", "continous", "continous", "discrete", "discrete", "discrete", "discrete", "continous", "continous") )) 

# calculate the correlation  
cor_minSbSd <- cor.test(bigDF_minSbSd$mean_VSS, bigDF_minSbSd$mean_corrSD)

# correlation: cor = .83, P-value = .006
ggplot(bigDF_minSbSd) +
   geom_smooth(aes(y = mean_corrSD, x = mean_VSS), method = "lm", col = "grey30", se = FALSE, fullrange = TRUE, lty = 2) +
  #geom_point(aes(x = mean_VSS, y = mean_corrSD)) + 
  geom_pointrange(aes(x = mean_VSS, y = mean_corrSD, 
                      xmin = (mean_VSS - (2*sd_VSS)), 
                      xmax = (mean_VSS + (2*sd_VSS)), 
                      col = VitalRate, 
                      pch = VitalRateType)) +
  geom_pointrange(aes(x = mean_VSS, y = mean_corrSD, 
                      ymin = mean_corrSD - (2*sd_corrSD), 
                      ymax = mean_corrSD + (2*sd_corrSD), 
                      col = VitalRate, 
                      pch = VitalRateType)) + 
  xlab("mean VSS") +
  ylab("mean corrected SD") + 
  geom_label(aes(x = 1.5, y = -1, 
                label = paste0("corr. = ", round(cor_minSbSd$estimate, 2),"; P-val = ", round(cor_minSbSd$p.value, 3))),
             label.size = NA) +
  theme_classic() +
  scale_colour_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00","#f3d210","#A65628", "#F781BF", "#7a7a7a"), name = "Vital Rate", labels = c("Flowering (Pb(z))", "goCont", "goSB", "Growth (G(z',z))", "outSB","Recruit size (c\u2092(z'))", "Seed prod. (b(z))", "staySB", "Survival (s(z))")) + 
  scale_shape_manual(values = c(16,17), name = "Vital Rate Type")#+
  #labs(title = "Correlation between Mean VSS and mean corrected SD for each vital rate \n with *minimum* variation in discrete seedbank vital rates")

```


Do the comparison using the maximum simulated standard deviation for discrete seedbank parameters
```{r}
# calculate the mean of sd and mean of VSS for each vital rate
bigDF_maxSbSd <-  bigDF %>% 
  filter(VitalRate %in% c("surv", "seedProd", "flowerProb")) %>% 
  group_by(VitalRate) %>% 
  summarize(mean_VSS = mean(VSS),
            sd_VSS = sd(VSS), 
            mean_corrSD = mean(correctedSD), 
            sd_corrSD = sd(correctedSD)) %>% 
  rbind(c("outSB", VSS.outSB, NA, corr.outSB.sd, NA)) %>% 
  rbind(c("staySB", VSS.staySB, NA, corr.staySB.sd, NA)) %>% 
  rbind(c("goCont" , VSS.goCont, NA, corr.goCont.sd, NA)) %>% 
  rbind(c("goSB", VSS.goSB, NA, corr.goSB.sd, NA)) %>% 
  rbind(c("growth", mean(VSS.growth), sd(VSS.growth), mean(corr.growth.sd), sd(corr.growth.sd))) %>%
  rbind(c("seedlingSize", mean(VSS.SeedlingSize), sd(VSS.SeedlingSize), mean(corr.seedlingSize.sd), sd(corr.seedlingSize.sd))) %>% 
  mutate(across(!VitalRate, as.numeric)) %>% 
  left_join(data.frame("VitalRate" = c("flowerProb", "seedProd", "surv", "outSB", "staySB","goCont", "goSB", "growth", "seedlingSize"), "VitalRateType" = c("continous", "continous", "continous", "discrete", "discrete", "discrete", "discrete", "continous", "continous") ))

# calculate the correlation  
cor_maxSbSd <- cor.test(bigDF_maxSbSd$mean_VSS, bigDF_maxSbSd$mean_corrSD)
  
ggplot(bigDF_maxSbSd) +
   geom_smooth(aes(y = mean_corrSD, x = mean_VSS), method = "lm", col = "grey30", se = FALSE, fullrange = TRUE, lty = 2) +
  #geom_point(aes(x = mean_VSS, y = mean_corrSD)) + 
  geom_pointrange(aes(x = mean_VSS, y = mean_corrSD, 
                      xmin = (mean_VSS - (2*sd_VSS)), 
                      xmax = (mean_VSS + (2*sd_VSS)), 
                      col = VitalRate, 
                      pch = VitalRateType)) +
  geom_pointrange(aes(x = mean_VSS, y = mean_corrSD, 
                      ymin = mean_corrSD - (2*sd_corrSD), 
                      ymax = mean_corrSD + (2*sd_corrSD), 
                      col = VitalRate, 
                      pch = VitalRateType)) + 
  xlab("mean VSS") +
  ylab("mean corrected SD") + 
  geom_label(aes(x = 1.5, y = -.8, label = paste0("corr. = ", round(cor_maxSbSd$estimate, 2),"; P-val = ", round(cor_maxSbSd$p.value, 3))),
             label.size = NA) +
  theme_classic() +
  scale_colour_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00","#f3d210","#A65628", "#F781BF", "#7a7a7a"), name = "Vital Rate", labels = c("Flowering (Pb(z))", "goCont", "goSB", "Growth (G(z',z))", "outSB","Recruit size (c\u2092(z'))", "Seed prod. (b(z))", "staySB", "Survival (s(z))")) + 
  scale_shape_manual(values = c(16,17), name = "Vital Rate Type")#+
  #labs(title = "Correlation between Mean VSS and mean corrected SD for each vital rate \n with *maximum* variation in discrete seedbank vital rates")
```


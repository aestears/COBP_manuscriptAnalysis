---
title: "Integral Projection Models for *Oenothera coloradensis*: Analysis of Vital Rate Buffering"
author: "Alice Stears"
date: "2023-05-16"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(popbio)
```

## IPM Equations

#### continuous, above-ground state:
$$ n(z',t_1) = \int^U_L [1-P_b(z)]s(z)G(z',z)n(z,t)dz + goCont \int^U_LP_b(z)b(z)c_o(z')n(z,t)dz + outSB[B(t)c_o(z')]$$     

#### discrete, seedbank state:
$$ B(t+1) = goSB \int^U_LP_b(z)b(z)n(z,t)dz + B(t)staySB$$    

where:

-   $G(z',z)$ is the distribution of plant size in year *t+1* as a
    function of size in year *t*\
-   $s(z)$ is the probability of survival based on size in year *t*\
-   $P_b(z)$ is the probability of flowering based on size in year
    *t*\
-   $b(z)$ is the number of seeds produced by a flowering plant based
    on size in year *t*\
-   $c_o(z')$ is the distribution of above-ground recruit size in
    year *t+1*        
-   $goCont$ is the discrete probability of a seed produced in year *t* germinating as a seedling in year *t+1*       
-   $outSB$ is the discrete probability of a seed from the seedbank in year *t* germinating as a seedling in year *t+1*       
-   $goSB$ is the discrete probability of a seed produced in year *t* going to the seedbank in year *t+1*       
-   $staySB$ is the discrete probability of a seedbank seed in year *t* persisting in the seedbank in year *t+1*        

## Prepare to make IPMs

#### load data

```{r}
# location of files
datFolder <- "~/Dropbox/Work/Grad School/Research/Oenothera coloradensis project/COBP_analysis/other_scripts/VSS_codeData/"
# load data file
dat_all <- read.csv(file = paste0(datFolder, "/allDat_plus_contSeedlings.csv"))
```

## Make IPMs 
Below is example code showing how I created an IPM for one of the six sub-populations. In this analysis, I calculated an IPM for each sub-population in each transition (a total of 12 IPMs, called IPMs CC through NN), which were used to calculate the mean and standard deviations of each vital rate. I also calculated an IPM using data from all subpopulations in both transitions, which I used to calculate sensitivity and elasticity for each vital rate. All of these IPMs used the same structure, but had different vital rate function parameters. 
```{r, eval = FALSE}
# establish upper and lower bounds of the continous state
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum ln(size), -2.8
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum ln(size), 4.4

n <-500 # bins

# These are the parameters for the discrete stages
outSB <- outSB_all #SB to continuous stage, 0.14
staySB <- staySB_all # staying in SB, 0.75
goCont <- goCont_all # seeds become continuous right away (without going to the seed bank), 0.09
goSB <- goSB_all # seeds go to the seedbank, 0.49
surv.seeds <-  0.9 # survival of seeds

## make an IPM for the "Crow Creek" site in the 2019-2020 transition
i <- 1
  ## get data for this 'current' site
  dat_now <- dat_all[dat_all$Site == unique(dat_all$Site)[i] # data for this site
                     & dat_all$Year == 2019# data for this year
                     ,]
  
  ## fit vital rate models
  ## Survival ($s(z)$)
  survDat_now <- dat_now[dat_now$flowering==0 | is.na(dat_now$flowering),]
  survMod_now <- glm(survives_tplus1 ~ log_LL_t , data = survDat_now, family = binomial)
  ## Growth ($G(z',z)$)
  sizeMod_now <- lm(log_LL_tplus1 ~ log_LL_t , data = dat_now)
  ## Number of seeds produced, according to plant size ($b(z)$)
  seedDat_now <- dat_now[dat_now$flowering==1,]
  # fit poisson glm (for count data)
  seedMod_now <- MASS::glm.nb(Num_seeds ~ log_LL_t , data = seedDat_now)
  ## Flowering probability ($p_b(z)$)
  flwrMod_now <- suppressWarnings((glm(flowering ~ log_LL_t + I(log_LL_t^2) , data = dat_now, family = binomial)))
  ## Distribution of recruit size ($c_o(z')$)
  # subset the data
  recD_now <- dat_all[dat_all$seedling == 1 & dat_all$Year == 2020,]
  # fit the model
  recMod_now <- lm(log_LL_t ~ 1, data = recD_now)
  
  ## put in the parameter list (paramCont)
  paramCont <- list(
    g_int     = coef(sizeMod_now)[1], # growth 
    g_slope   = coef(sizeMod_now)[2],
    g_sd      = summary(sizeMod_now)$sigma,
    s_int     = coef(survMod_now)[1], # survival
    s_slope   = coef(survMod_now)[2],
    p_b_int   = coef(flwrMod_now)[1], #probability of flowering
    p_b_slope = coef(flwrMod_now)[2],
    p_b_slope_2 = coef(flwrMod_now)[3],
    b_int   = coef(seedMod_now)[1], #seed production
    b_slope = coef(seedMod_now)[2],
    c_o_mu    = coef(recMod_now), #recruit size distribution
    c_o_sd    = summary(recMod_now)$sigma,
    outSB  = outSB_all,
    staySB = staySB_all,
    goSB   = goSB_all, 
    goCont = goCont_all                  
  )
  ## make vital rate functions for the IPM
  # SURVIVAL:
  S.fun <- function(z, paramCont) {
    mu.surv=paramCont$s_int + paramCont$s_slope *z
    return(1/(1 + exp(-(mu.surv))))
  }
  # GROWTH (we assume a constant variance)
  GR.fun <- function(z,zz, paramCont){
    growth.mu = paramCont$g_int + paramCont$g_slope*z
    return(dnorm(zz, mean = growth.mu, sd = paramCont$g_sd))
  }
  ## SEEDLING SIZES (same approach as in growth function)
  SDS.fun <- function(zz, paramCont){
    rec_mu <- paramCont$c_o_mu
    rec_sd <- paramCont$c_o_sd
    return(dnorm(zz, mean = rec_mu, sd = rec_sd))
  }
  # PROBABILITY OF FLOWERING 
  FL.fun <- function(z, paramCont) {
    mu.fl = paramCont$p_b_int + paramCont$p_b_slope*z +  paramCont$p_b_slope_2 * (z^2)
    return(1/(1+ exp(-(mu.fl))))
  }
  # SEED PRODUCTION
  SDP.fun <- function(z, paramCont) {
    mu.fps=exp(paramCont$b_int + paramCont$b_slope *z)
    return(mu.fps)
  }
  
  ## fit the IPM
  K <- array(0,c(n+1,n+1))
  # Setting up the kernels
  b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
  meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
  h=(U-L)/n # bin width 
  # Survival and growth 
  S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
  G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth
  # G <- t(outer(meshp,meshp,GR.fun)) # Growth
  #Recruits distribution (seeds recruited from the seedbank into the continuous stage)
  c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)
  # c_o <- matrix(rep(SDS.fun(meshp),n),n,n,byrow=F)
  #Probability of flowering
  Pb = (FL.fun(meshp, paramCont))
  #Number of seeds produced according to adult size
  b_seed = (SDP.fun(meshp, paramCont))
  FecALL= Pb * b_seed
  # update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
  S_new <- S * (1-Pb)
  # Control for eviction:
  # this is equivalent to redistributing evicted sizes evenly among existing size classes 
  G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
  c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)
  # make the continuous part of the P matrix
  Pkernel.cont <- as.matrix(G %*% S_new)
  # seedbank (first column of your K)
  Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous
  # Make the full P kernel
  Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component
  ## make the F kernel
  Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class
  Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)
  Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))
  
  mat <-Pkernel+Fkernel
  
  eigenMat <- eigen(mat)
  
  IPMs_II_NN[[i]] <- list(KMatrix = mat,
                          GMatrix = G, 
                          SMatrix = S_new,
                          FMatrix = Fkernel.cont,
                          staySB_vec = staySB, 
                          leaveSB_vec = as.matrix((outSB*c_o[,1]), nrow = 500, ncol = 1), 
                          goSB_vec = matrix(c( goSB * (FecALL)), nrow = 1),
                          params = paramCont)

```
#### To save time, we can load the saved IPMs that were calculated previously
```{r, message=FALSE}
# subpopulation-level, each transition IPMs
IPMs_CC_HH <- readRDS(paste0(datFolder,"IPMs_CC_HH.RDS"))
IPMs_II_NN <- readRDS(paste0(datFolder,"IPMs_II_NN.RDS"))
# all populations, all transitions IPM
load(paste0(datFolder,"ipmA_B_results.RData"))
```

## Calculate mean and corrected standard deviation of Vital Rates
#### * Based on the VSS code for matrix models that Maria Paniw shared

Put all of the IPMs for each subpopulation/transition into one big list
```{r}
allIPMs <- c(IPMs_II_NN, IPMs_CC_HH)

# also define the vector of meshpoints that is used to make each IPM (which we'll need to calculate vital rate functions in the IPM)
n <- 500
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum ln(size), -2.8
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum ln(size), 4.4
# calculate the meshpoints
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)])
# calculate the binwidth
h <- diff(meshp)[1]
```

In this section we first extract the underlying vital rates, to then calculate their corrected standard deviation (according to McDonald et al. 2017). The corrections are required because we want to be able to include in the same analysis vital rates such as survival and growth (bounded between 0 and 1) and fecundity (bounded only by 0). The variance of 0-1 vital rates is constrained by a lower and upper limit, therefore these vital rates have to be transformed to free variance from this constraint.

#### Survival ($s(z)$) 
Use the survival function w/ parameters for each IPM to calculate the survival vector for each IPM (want just survival, not survival - probability of flowering)
```{r}
# survival function from the IPM
S.fun <- function(z, paramCont) {
  mu.surv=paramCont$s_int + paramCont$s_slope *z 
  return(1/(1 +exp(-(mu.surv)))) }
# calculate the survival probability based on model parameters for each IPM
# surv is a matrix with 500 rows (one for each meshpoint) and 12 columns (one for each subpop/year)
surv <- sapply(allIPMs, FUN = function(x) 
  S.fun(z =
meshp, paramCont = x$params) )

#Get the mean survival vector over all 12 IPMs (surv.mu is a vector with the mean survival rate for each cell of the IPM)
surv.mu <- apply(surv, 1, mean)

#Get the standard deviation of survival over all of the IPMs
surv.sd <- apply(surv, 1, sd)

# get the corrected sd (use a logit transformation, since it is a probability)
# (McDonald et al. (2017) used logit transformation on 0-1 vital rates)
corr.surv.sd <- apply(car::logit(surv,adjust = 0.001), 1 ,sd)
```

#### Probability of Flowering $(P_b(z))$

Use the flowering function w/ parameters for each IPM to calculate the P(flowering) vector for each IPM
```{r}
# PROBABILITY OF FLOWERING
FL.fun <- function(z, paramCont) { 
  mu.fl = paramCont$p_b_int + paramCont$p_b_slope*z + paramCont$p_b_slope_2* (z^2) 
  return(1/(1+ exp(-(mu.fl)))) }

# calculate the flowering probability based on model parameters for each IPM
flowering <- sapply(allIPMs, 
                    FUN = function(x) 
  FL.fun(z = meshp, paramCont = x$params) 
  ) 
# at this point, 'flowering' is a list where each list element is for a subpop/year, and contains a vector of flowering probabilities

# Now, calculate the mean flowering probability
# get a matrix that is an average of all of the different Fmats from each IPM 
flowering.mu <- apply(flowering, 1, mean) 

# sd of fecundity 
flowering.sd <- apply(flowering, 1, sd) 

# get the corrected sd (use a logit transformation, since it is a probability) McDonald et al. (2017) used logit transformation on 0-1 vital rates
corr.flowering.sd <- apply(car::logit(flowering,adjust = 0.001), 1,sd) 
```


#### Seed production ($b(z)$)

Use the seed production function w/ parameters for each IPM to calculate the seed production vector for each IPM
```{r}
# SEED PRODUCTION
SDP.fun <- function(z, paramCont) {
  mu.fps = exp(paramCont$b_int + paramCont$b_slope * z)
  return(mu.fps)
}

# calculate seed production based on model parameters for each IPM
seedProd <- lapply(
  allIPMs,
  FUN = function(x)
    SDP.fun(z = meshp, paramCont = x$params)
)


# at this point, 'seedProd' is a list where each list element is for a subpop/year, and contains a vector of seed production
# we need to make this into a full matrix
# first, make the continuous part (put the seed production vector on the diagonal)
seedProd.cont <- lapply(
  seedProd,
  FUN = function(x)
    as.matrix(diag(x))
)

# add discrete part (contribution of flowering probability to the seedbank)
seedProd.disc <- lapply(
  seedProd,
  FUN = function(x)
    matrix(c(0, x), nrow = 1)
)

# combine into one matrix
for (i in 1:length(seedProd.cont)) {
  seedProd[[i]] <-
    rbind(seedProd.disc[[i]], cbind(rep(0, length.out = 500),
                                    seedProd.cont[[i]]))
}

# are there any values of 0 in the seed production matrices?
unlist(lapply(seedProd, FUN = function(x) sum(x==0))) >0

# Since the correction that we must apply to fecundities is the
# log-transformation, we encounter problems when the the vital rate has a value
# of 0. The following if-else loops are needed to deal with fecundity matrices
# with "0" entries where they should have a positive value (0s are a problem
# because log transformation can't be done on the value "0"). Therefore, we add
# a small value (0.01) to the fecundity value which is 0, over all the years of
# the study. This way, we keep a biological meaning, and we stay consistent.

seedProd <- lapply(
  seedProd,
  FUN =
    function(x)
      replace(x, list = which(x == 0, arr.ind = TRUE), values =
                .0001)
) 

#Now, calculate mean seedProd probability
seedProd.mu <- apply(simplify2array(seedProd), 1:2, mean) 
# this is a matrix that is an average of all of the different seed production matrices from each IPM 

# sd of seed production 
seedProd.sd <- apply(simplify2array(seedProd), 1:2, sd)

# get the corrected sd (use a log transformation, since it is NOT a probability) 
corr.seedProd.sd <- apply(log(simplify2array(seedProd)), 1:2 ,sd) 
```

#### Growth $G(z',z)$
Use the growth function w/ parameters for each IPM to calculate the growth for each IPM
```{r}
# GROWTH (we assume a constant variance)
GR.fun <- function(z, zz, paramCont) {
  growth.mu =
    paramCont$g_int + paramCont$g_slope * z 
  return(dnorm(zz, mean = growth.mu, 
               sd =  paramCont$g_sd))
} 
# calculate the growth matrix based on model parameters for each IPM
growth <-
  lapply(allIPMs,
    FUN = function(x)
      h * t(outer(meshp, meshp, GR.fun, paramCont = x$params)
            )
    ) 
# 'growth' is a list in which each element contains the growth matrix for one subpop/year
    
#Calculate the mean of growth 
growth.mean <-
    apply(simplify2array(growth), 1:2, mean) 

# sd of growth 
growth.sd <-
    apply(simplify2array(growth), 1:2, sd) 

# corrected sd of growth (use a logit transformation, since it is a probability)
corr.growth.sd <-
  apply(car::logit(simplify2array(growth), adjust = 0.001), 1:2, sd)
```

#### We don't calculate mean and sd values for seedbank parameters and seedling size distribution, because those values were calculated at the population level (so there is no variation accross subpopulations)

## Calculate Sensitivity 

Calculate the sensitivity of each vital rate using the "Brute Force Method." 
Then, we calculate the corrected sensitivity for each rate according to McDonald et al. (2017)

We calculate the vital rate sensitivities based on the matrix from IPM B (called "mat_all_DI") (IPM for all sites and both transitions) (I think this is correct? not too sure? Should I calculate it from the mean matrix from all 12 subpop/year IPMs instead?)


### Calculate vital rate sensitivity
#### Preparation

First, get parameter values used to make the all pops, all transitions IPM, and save in a list
```{r}
# Empty list to save model coefficients 
paramCont=list(NULL)
# survival model is called 'survMod_all'
paramCont[[1]]=as.matrix(coef(survMod_all)) # save coefficients 
# growth model is called 'sizeMod_all'
paramCont[[2]]=cbind(as.matrix(coef(sizeMod_all)),sd(residuals(sizeMod_all))) # the third column is for the standard deviation of growth 
# seedling size distribution is a uniform distribution (of exp(size_2)) with a min of 0.1 and a max 0f 3
paramCont[[3]]= cbind(as.matrix(coef(recMod_all)), sd(residuals(recMod_all)))
# model for probability of flowering is flwrMod_all
paramCont[[4]]=as.matrix(coef(flwrMod_all))
# model for seed production per plant (if reproductive) is seedMod_all
paramCont[[5]]=as.matrix(coef(seedMod_all))
# name the paramCont list to keep track of coefficients
names(paramCont) <- c("survival", "growth", "recruitDist", "flowering", "seedProduction")

```

These are the parameters for the discrete stages
```{r}
outSB <- outSB_all #SB to continuous stage
staySB <- staySB_all # staying in SB
goCont <- goCont_all # seeds become continuous right away (without going to the seed bank) 
goSB <- goSB_all # seeds go to the seedbank
surv.seeds <-  0.9 # survival of seeds
```

Define starting conditions for the IPMs
```{r}
# Define the lower and upper integration limit
L <-  1.2 * min(dat_all$log_LL_t, na.rm = TRUE) # minimum size
U <-  1.2 * max(dat_all$log_LL_t, na.rm = TRUE) # maximum size

n <-500 # bins
```


Then, define the vital rate functions that are used to make the IPM (Same as the functions used to calculate mean and sd vital rate parameter values above)
```{r}
# SURVIVAL:
S.fun <- function(z, paramCont) {
  mu.surv=paramCont[["survival"]]["(Intercept)",] + paramCont[["survival"]]["log_LL_t",]*z
  return(1/(1 + exp(-(mu.surv))))
}
# GROWTH (we assume a constant variance)
GR.fun <- function(z,zz, paramCont){
  growth.mu = paramCont[["growth"]]["(Intercept)",1] + paramCont[["growth"]]["log_LL_t",1]*z
  return(dnorm(zz, mean = growth.mu, sd = paramCont[["growth"]][1,2]))
}
## SEEDLING SIZES (same approach as in growth function)
SDS.fun <- function(zz, paramCont){
  rec_mu <- paramCont[["recruitDist"]][1]
  rec_sd <- paramCont[["recruitDist"]][2]
  return(dnorm(zz, mean = rec_mu, sd = rec_sd))
}
# PROBABILITY OF FLOWERING 
FL.fun <- function(z, paramCont) {
  mu.fl = paramCont[["flowering"]][1,] + paramCont[["flowering"]][2,]*z +  paramCont[["flowering"]][3,]* (z^2)
  return(1/(1+ exp(-(mu.fl))))
}
# SEED PRODUCTION
SDP.fun <- function(z, paramCont) {
  mu.fps=exp(paramCont[["seedProduction"]][1,1] + paramCont[["seedProduction"]][2,1]*z)
  return(mu.fps)
}
```

Save the lambda and vital rate function values from the unpurturbed IPM
```{r}
# lambda value
lambda_OG <- lam_all_DI

## vital rate functions
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width  

# survival
surv_OG <- S.fun(meshp, paramCont)
  
# growth
growth_OG <- t(outer(meshp,meshp,GR.fun, paramCont)) # don't multiply by h... so no integration? is this correct?

# seedling size distribution
seedlingSize_OG <-  matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F) # don't multiply by h... so no integration? is this correct?

# probability of flowering
flowering_OG <- (FL.fun(meshp, paramCont))

# numbers of seeds produced 
seedProd_OG <- (SDP.fun(meshp, paramCont))
```

#### Sensitivity to Survival $s(z)$    
Calculate the un-corrected sensitivity of the IPM matrix to changes in the survival function by calculating the IPM matrix with slightly perturbed survival function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- 0.05

## redefine the survival function to add a tiny value 
S.fun_pert <- function(z, paramCont) {
  mu.surv=paramCont[["survival"]]["(Intercept)",] + paramCont[["survival"]]["log_LL_t",]*z 
  return(1/(1 + exp(-(mu.surv))) + perturbVal)
}
# Survival and growth 
S<- diag(S.fun_pert(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth
# G <- t(outer(meshp,meshp,GR.fun)) # Growth

#Recruits distribution (seeds recruited from the seedbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)
# c_o <- matrix(rep(SDS.fun(meshp),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# seedbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_Survival <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_Survival)
# get and save the purturbed lambda
lambda_perturb_Survival <-eigenMat$values[1]
# get and save the purturbed vital rate function
s_perturb <- S.fun_pert(meshp, paramCont)
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{s(z)} = \frac{\Delta\lambda}{\Delta s(z)} = \frac{\lambda_{perturb} - \lambda_{original}}{s(z)_{perturb} - s(z)_{original}}$$
```{r}
sens_Surv <- as.numeric(lambda_perturb_Survival - lambda_OG) / (s_perturb - surv_OG)

plot(sens_Surv, type = "l")
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival and growth.

VSS for $s(z)$ = $$\frac{s(z)(1-s(z))}{\lambda} \frac{\delta\lambda}{\delta s(z)}$$
where $\frac{\delta\lambda}{\delta s(z)}$ is the sensitivity calculated above
```{r}
# VSS on survival 
# first, add a '0' to the beginning of the surv.mu and surv.sd vectors (for the seedbank, which doesn't 'survive')
# called "surv.mu" and "surv.sd" #(we'll use this later for the vr buffering analysis)

# calculate VSS 
VSS.surv <- as.numeric(sens_Surv * ((surv.mu*(1-surv.mu))/lambda_OG))

# compare VSS of survival to un-corrected sensitivity to survival (the dashed line is the VSS)
plot(sens_Surv,type = "l", ylim = c(0,2.6))
lines(VSS.surv, lty = 2)
```

#### Sensitivity to Flowering probability $P_b(z)$
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the flowering function by calculating the IPM matrix with slightly perturbed flowering function 
%%% I'm really not sure where I should add the perturbation to this function? Based on example code from Levin ESA workshop, added it after the logit transformation??
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- 0.005

## redefine the flowering probability function to add a tiny value 
# PROBABILITY OF FLOWERING 
FL.fun_pert <- function(z, paramCont) {
  mu.fl = paramCont[["flowering"]][1,] + paramCont[["flowering"]][2,]*z +  paramCont[["flowering"]][3,]* (z^2) 
  return(1/(1+ exp(-(mu.fl))) + perturbVal)
}
# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth
# G <- t(outer(meshp,meshp,GR.fun)) # Growth

#Recruits distribution (seeds recruited from the seedbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)
# c_o <- matrix(rep(SDS.fun(meshp),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun_pert(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# seedbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_Flowering <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_Flowering)
# get and save the perturbed lambda
lambda_perturb_Flowering <-eigenMat$values[1]
# get and save the perturbed vital rate function
Pb_perturb <- FL.fun_pert(meshp, paramCont)
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{Pb(z)} = \frac{\Delta\lambda}{\Delta Pb(z)} = \frac{\lambda_{perturb} - \lambda_{original}}{Pb(z)_{perturb} - Pb(z)_{original}}$$
```{r}
sens_Flowering <- as.numeric(lambda_perturb_Flowering - lambda_OG) / (Pb_perturb - flowering_OG)

plot(sens_Flowering, type = "l")
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $s(z)$ = $$\frac{Pb(z)(1-Pb(z))}{\lambda} \frac{\delta\lambda}{\delta Pb(z)}$$
where $\frac{\delta\lambda}{\delta Pb(z)}$ is the sensitivity calculated above
```{r}
# VSS on flowering probability 

# calculate VSS 
VSS.flwr <- as.numeric(sens_Flowering * ((flowering.mu*(1-flowering.mu))/lambda_OG))

# compare VSS of flowering to un-corrected sensitivity to flowering (the dashed line is the VSS)
  plot(sens_Flowering,type = "l",ylim = c(0,7)
       )
lines(VSS.flwr, lty = 2)
```

#### Sensitivity to Seed production  $P_b(z)$
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the seed production function by calculating the IPM matrix with slightly perturbed seed production function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- 6

## redefine the seed production function to add a tiny value 
# SEED PRODUCTION
SDP.fun_pert <- function(z, paramCont) {
  mu.fps=exp(paramCont[["seedProduction"]][1,1] + paramCont[["seedProduction"]][2,1]*z)  
  return(mu.fps + perturbVal)
}

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun, paramCont)) # Growth

#Recruits distribution (seeds recruited from the seedbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun_pert(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# seedbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_SeedProd <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_SeedProd)
# get and save the purturbed lambda
lambda_perturb_SeedProd <-eigenMat$values[1]
# get and save the purturbed vital rate function
b_perturb <- SDP.fun_pert(meshp, paramCont)
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{b(z)} = \frac{\Delta\lambda}{\Delta b(z)} = \frac{\lambda_{perturb} - \lambda_{original}}{b(z)_{perturb} - b(z)_{original}}$$
```{r}
sens_SeedProd <- as.numeric(lambda_perturb_SeedProd - lambda_OG) / (b_perturb - seedProd_OG)

plot(sens_SeedProd, type = "l", ylim = c(0, .005))
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. Because this is a number (not a probability), the VSS corresponds to the elasticity, which is found by scaling the sensitivity function by (survival / lambda): 

Elasticity for $b(z)$ = $$\frac{\delta \lambda}{\delta b(z)} * \frac{b(z)}{\lambda} $$
where $\frac{\delta\lambda}{\delta b(z)}$ is the sensitivity calculated above
```{r}
# VSS on Seed production  

# calculate VSS 
VSS.seeds <- sens_SeedProd * (SDP.fun(meshp, paramCont)/as.numeric(lambda_OG))

# compare to untransformed sensitivity
plot(sens_SeedProd, type = "l", ylim = c(0, 4.5))
lines(VSS.seeds, lty = 2)
```

#### Sensitivity to growth probability $G(z',z)$
 
Calculate the un-corrected sensitivity of the IPM matrix to changes in the growth probability function by calculating the IPM matrix with slightly perturbed growth probability function 
```{r}
# Setting up the kernels
K <- array(0,c(n+1,n+1))
b <- L+c(0:n)*(U-L)/n # interval that each cell of the matrix covers 
meshp <- 0.5*(b[1:n]+b[2:(n+1)]) # midpoint
h=(U-L)/n # bin width 

## set the perturbation value (should be ~1% of the vital rate value)
perturbVal <- .01

## redefine the growth probability function to add a tiny value 
  # GROWTH (we assume a constant variance)
GR.fun_pert <- function(z,zz, paramCont){
  growth.mu = paramCont[["growth"]]["(Intercept)",1] + paramCont[["growth"]]["log_LL_t",1]*z + perturbVal
  return(dnorm(zz, mean = growth.mu, sd = paramCont[["growth"]][1,2]))
}

# Survival and growth 
S <- diag(S.fun(meshp, paramCont)) # Survival # put survival probabilities in the diagonal of the matrix
G <- h * t(outer(meshp,meshp,GR.fun_pert, paramCont)) # Growth

#Recruits distribution (seeds recruited from the seedbank into the continuous stage)
c_o <- h * matrix(rep(SDS.fun(meshp, paramCont),n),n,n,byrow=F)

#Probability of flowering
Pb = (FL.fun(meshp, paramCont))

#Number of seeds produced according to adult size
b_seed = (SDP.fun(meshp, paramCont))

FecALL= Pb * b_seed

# update the 'S' matrix by multiplying it by (1-Pb), since this is a monocarpic perennial
S_new <- S * (1-(Pb))

# Control for eviction:
# this is equivalent to redistributing evicted sizes evenly among existing size classes 
G <- G/matrix(as.vector(apply(G,2,sum)),nrow=n,ncol=n,byrow=TRUE)
c_o <- c_o/matrix(as.vector(apply(c_o,2,sum)),nrow=n,ncol=n,byrow=TRUE)

# make the continuous part of the P matrix
Pkernel.cont <- as.matrix(G %*% S_new)

# seedbank (first column of your K)
Pkernel.seedbank = c(staySB, outSB*c_o[,1]) # seeds survive and go to continuous

# Make the full P kernel
Pkernel <- cbind(Pkernel.seedbank,rbind(rep(0,length(meshp)),Pkernel.cont)) # discrete component

## make the F kernel
Fkernel.cont <-  as.matrix(goCont * ((c_o) %*% diag(FecALL))) # the size of seedlings that go into the seed bank from each continuous size class

Fkernel.discr  <- matrix(c(0, goSB * (FecALL)), nrow = 1)

Fkernel <- rbind(Fkernel.discr, cbind(rep(0, length.out = n),Fkernel.cont))

ipm_perturb_Growth <-Pkernel+Fkernel

eigenMat <- eigen(ipm_perturb_Growth)
# get and save the purturbed lambda
lambda_perturb_Growth <-eigenMat$values[1]
# get and save the purturbed vital rate function
G_perturb <- t(outer(meshp,meshp,GR.fun_pert, paramCont))
```

Now, calculate the sensitivity by comparing the perturbed to unperturbed lambdas and vital rate function of interest
$$Sens_{G(z',z)} = \frac{\Delta\lambda}{\Delta G(z',z)} = \frac{\lambda_{perturb} - \lambda_{original}}{G(z',z)_{perturb} - G(z',z)_{original}}$$
```{r}
sens_Growth <- as.numeric(lambda_perturb_Growth - lambda_OG) / (G_perturb - growth_OG)

#image(sens_Growth)
```

Now, calculate the corrected sensitivity (VSS) based on code from Maria, which 
is in turn based on McDonald et al., 2017. This correction accounts for 0-1 
boundaries in vital rates such as survival, growth, or flowering probability.

VSS for $G(z',z)$ = $$\frac{G(z',z)(1-G(z',z))}{\lambda} \frac{\delta\lambda}{\delta G(z',z)}$$
where $\frac{\delta\lambda}{\delta Pb(z)}$ is the sensitivity calculated above
```{r}
# VSS on growth probability 

# calculate VSS 
VSS.growth <- sens_Growth * ((growth.mean*(1-growth.mean))/as.numeric(lambda_OG))
#image(VSS.growth)
```

